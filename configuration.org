* Emacs Configuration

This emacs configuration is inspired by Harry R. Schwartz's "Getting
started with Org mode" [[https://www.youtube.com/watch?v%3DSzA2YODtgK4][talk]].

* Package Management
** Use the =package= package to manage packages

#+begin_src emacs-lisp
  (require 'package)
#+end_src

** Repositories

  Setup the package repositories. I use the canonical GNU repository, as
  well as a handful of community supported repositories.

  #+BEGIN_SRC emacs-lisp
    (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                             ("melpa" . "https://melpa.org/packages/")
                             ("org" . "http://orgmode.org/elpa/")))
  #+END_SRC

** =use-package=

  Make sure use-package is installed. use-package is used to install,
  and load/configure packages lazily. This should be the only package
  that needs to be explicitly installed via the =package.el= manager.

  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package)
      (require 'use-package))
  #+END_SRC

* Path Management

  Emacs 27 set the default directory to =/=, but I prefer to start my
  Emacs sessions from the user's =$HOME= directory.

  #+begin_src emacs-lisp
    (setq default-directory "~/")
  #+end_src

  The path must explicitly be loaded into Emacs on Mac OS X. NOTE: this
  happens automatically on Linux.

  #+BEGIN_SRC emacs-lisp
    (use-package exec-path-from-shell
      :if (memq window-system '(mac ns x))
      :ensure t
      :config
      (exec-path-from-shell-initialize)
      (setq exec-path (cons "/opt/local/bin" exec-path))
      (setenv "PATH" (concat "/opt/local/bin:" (getenv "PATH"))))
  #+END_SRC

* UI Preferences

** Set font size

   I like a slightly larger than usual font. This little helper allows
   me to describe and set the font size in "points"

   #+BEGIN_SRC emacs-lisp
     (defun set-font-size (points)
       (interactive "n Font Size in Points: ")
       (cl-flet ((font-height (points) (* 10 points)))
         (set-face-attribute 'default nil :height (font-height points))))

     (set-font-size 14)
   #+END_SRC

** Hide emacs startup message

   I don't find the emacs welcome message useful, so prevent it on startup.

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
   #+END_SRC

** Disable default scratch buffer message

   I don’t find the explanatory message of the scratch buffer useful, so don’t show it.

   #+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message "")
   #+END_SRC

** Show the point's line and column numbers

   I don't use fringe line number, but I still like knowing the
   coordinates of my point. This enables the mode-line point coordinates.

   #+BEGIN_SRC emacs-lisp
     (line-number-mode t)
     (column-number-mode t)
   #+END_SRC

** Initialize the color-theme

   Let's try out Prot's =modus= themes!

   #+BEGIN_SRC emacs-lisp
     (defmacro modus-themes-format-sexp (sexp &rest objects)
       `(eval (read (format ,(format "%S" sexp) ,@objects))))

     (dolist (theme '("vivendi" "operandi"))
       (modus-themes-format-sexp
        (defun modus-%1$s-theme-load ()
          (setq modus-%1$s-theme-slanted-constructs t
                modus-%1$s-theme-bold-constructs t
                modus-%1$s-theme-fringes 'subtle ; {nil,'subtle,'intense}
                modus-%1$s-theme-mode-line '3d ; {nil,'3d,'moody}
                modus-%1$s-theme-syntax 'alt-syntax ; {nil,faint,'yellow-comments,'green-strings,'yellow-comments-green-strings,'alt-syntax,'alt-syntax-yellow-comments}
                modus-%1$s-theme-intense-hl-line t
                modus-%1$s-theme-intense-paren-match t
                modus-%1$s-theme-links 'faint ; {nil,'faint,'neutral-underline,'faint-neutral-underline,'no-underline}
                modus-%1$s-theme-no-mixed-fonts nil
                modus-%1$s-theme-prompts nil ; {nil,'subtle,'intense}
                modus-%1$s-theme-completions 'moderate ; {nil,'moderate,'opinionated}
                modus-%1$s-theme-diffs nil ; {nil,'desaturated,'fg-only}
                modus-%1$s-theme-org-blocks 'grayscale ; {nil,'grayscale,'rainbow}
                modus-%1$s-theme-headings  ; Read further below in the manual for this one
                '((1 . section)
                  (2 . line)
                  (t . rainbow-line-no-bold))
                modus-%1$s-theme-variable-pitch-headings nil
                modus-%1$s-theme-scale-headings t
                modus-%1$s-theme-scale-1 1.1
                modus-%1$s-theme-scale-2 1.15
                modus-%1$s-theme-scale-3 1.21
                modus-%1$s-theme-scale-4 1.27
                modus-%1$s-theme-scale-5 1.33)
          (load-theme 'modus-%1$s t))
        theme))

     (defun modus-themes-toggle ()
       "Toggle between `modus-operandi' and `modus-vivendi' themes."
       (interactive)
       (if (eq (car custom-enabled-themes) 'modus-operandi)
           (progn
             (disable-theme 'modus-operandi)
             (modus-vivendi-theme-load))
         (disable-theme 'modus-vivendi)
         (modus-operandi-theme-load)))

     (modus-vivendi-theme-load)
   #+END_SRC

** Disable menu, toolbar, and scrollbar UI elements

   I don't use the menu or scrollbar UI elements so I disable them to
   get back some screen real estate

   #+BEGIN_SRC emacs-lisp
     (use-package menu-bar
       :commands menu-bar-mode
       :init (menu-bar-mode -1))

     (use-package tool-bar
       :commands tool-bar-mode
       :init (tool-bar-mode -1))

     (use-package scroll-bar
       :commands scroll-bar-mode
       :init
       (scroll-bar-mode -1)
       (when (fboundp 'horizontal-scroll-bar-mode)
   (horizontal-scroll-bar-mode -1)))
   #+END_SRC

   Always highlight the current line of the point.

   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode)
   #+END_SRC

** Line Wrapping

   Use soft line wrapping for text modes

   #+BEGIN_SRC emacs-lisp
     (add-hook 'markdown-mode-hook 'visual-line-mode)
     (add-hook 'org-mode-hook 'visual-line-mode)
   #+END_SRC

** Region Highlighting

   Make the region selection a bit easier to see.

   #+begin_src emacs-lisp
     (set-face-attribute 'region nil :background "#666")
   #+end_src

* Buffer preferences

** Prefer two space character indentation

   In my experience, whitespace is more portable than <tab>
   characters. As such, I use two white-space characters for
   indentation.

   #+BEGIN_SRC emacs-lisp
     (setq-default tab-width 2)
     (setq-default indent-tabs-mode nil)
   #+END_SRC

** Ensure that files end with a newline character

   This tends to be part of the code-style of many organizations for
   which I do work and it doesn't hurt to make sure that the last
   character in any file is a \n character so I make it the default.

   #+BEGIN_SRC emacs-lisp
     (setq require-final-newline t)
   #+END_SRC

** Remove trailing whitespace on save

   Extra end-of-line whitespace bugs me, but I'm also prone to
   introducing it so automatically trim trailing whitespace when a
   buffer is saved.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook 'whitespace-cleanup)
   #+END_SRC

** Show and match bracket pairs

   Highligh matching brackets and when I open a bracket, autmaically
   close it for me:

   For example: [], (), {}, et cetera.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode t)
     (electric-pair-mode t)
   #+END_SRC

** Allow deletion of highlighted regions

   I like to be able to select a region and delete it.

   #+BEGIN_SRC emacs-lisp
     (delete-selection-mode t)
   #+END_SRC

** Undo

   I've oft found the default Emacs undo functionality gets a bit
   confusing when undo/redo comes into play. [[https://github.com/terryfinn][Terry]] agrees and uses undo-tree to get around this

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :ensure t
       :init
       (global-undo-tree-mode))
   #+END_SRC

** Buffer lists

  Use =ibuffer= as the default buffer list

  #+begin_src emacs-lisp
    (use-package ibuffer
      :config
      (setq ibuffer-expert t)
      (setq ibuffer-display-summary nil)
      (setq ibuffer-use-other-window nil)
      (setq ibuffer-show-empty-filter-groups nil)
      (setq ibuffer-movement-cycle nil)
      (setq ibuffer-default-sorting-mode 'filename/process)
      (setq ibuffer-use-header-line t)
      (setq ibuffer-default-shrink-to-minimum-size nil)
      (setq ibuffer-formats
            '((mark modified read-only locked " "
                    (name 30 30 :left :elide)
                    " "
                    (size 9 -1 :right)
                    " "
                    (mode 16 16 :left :elide)
                    " " filename-and-process)
              (mark " "
                    (name 16 -1)
                    " " filename)))
      (setq ibuffer-saved-filter-groups nil)
      (setq ibuffer-old-time 48)

      (defun prot/buffers-major-mode (&optional arg)
        "Select buffers that match the current buffer's major mode.
    With \\[universal-argument] produce an `ibuffer' filtered
    accordingly.  Else use standard completion."
        (interactive "P")
        (let* ((major major-mode)
               (prompt "Buffers for ")
               (mode-string (format "%s" major))
               (mode-string-pretty (propertize mode-string 'face 'success)))
          (if arg
              (ibuffer t (concat "*" prompt mode-string "*")
                       (list (cons 'used-mode major)))
            (switch-to-buffer
             (read-buffer
              (concat prompt mode-string-pretty ": ") nil t
              (lambda (pair) ; pair is (name-string . buffer-object)
                (with-current-buffer (cdr pair) (derived-mode-p major))))))))

      (defun prot/buffers-vc-root (&optional arg)
        "Select buffers that match the present `vc-root-dir'.
    With \\[universal-argument] produce an `ibuffer' filtered
    accordingly.  Else use standard completion.

    When no VC root is available, use standard `switch-to-buffer'."
        (interactive "P")
        (let* ((root (vc-root-dir))
               (prompt "Buffers for VC ")
               (vc-string (format "%s" root))
               (vc-string-pretty (propertize vc-string 'face 'success)))
          (if root
              (if arg
                  (ibuffer t (concat "*" prompt vc-string "*")
                           (list (cons 'filename (expand-file-name root))))
                (switch-to-buffer
                 (read-buffer
                  (concat prompt vc-string-pretty ": ") nil t
                  (lambda (pair) ; pair is (name-string . buffer-object)
                    (with-current-buffer (cdr pair) (string= (vc-root-dir) root))))))
            (call-interactively 'switch-to-buffer))))

      :hook (ibuffer-mode-hook . hl-line-mode)
      :bind (("M-s b" . prot/buffers-major-mode)
             ("M-s v" . prot/buffers-vc-root)
             ("C-x C-b" . ibuffer)
             :map ibuffer-mode-map
             ("* f" . ibuffer-mark-by-file-name-regexp)
             ("* g" . ibuffer-mark-by-content-regexp) ; "g" is for "grep"
             ("* n" . ibuffer-mark-by-name-regexp)
             ("s n" . ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
             ("/ g" . ibuffer-filter-by-content)))
  #+end_src

* Window preferences

** Arrangement

   I edit multiple buffers across many open windows. Organization of
   these windows becomes a chore and I always forget the window
   resizing chords. [[https://github.com/terryfinn][Terry]] said "Give [[https://truongtx.me/2014/11/15/auto-resize-windows-by-golden-ratio-in-emacs][this]] a shot!" So I'm giving this
   a shot.

   #+BEGIN_SRC emacs-lisp
     (use-package golden-ratio
       :ensure t
       :init
       (setq split-width-threshold nil)
       :config
       (golden-ratio-mode 1))
   #+END_SRC

* Authentication

  Some of my emacs packages, like =magit=, require authentication
  credentials to interact with 3rd party services I use, like
  =Github=, =Gitlab=, etc. I store credentials encrypted by my GPG
  keys in =~/.authinfo.gpg=. Here I tell emacs where to find such credentials.

  To create the =~/.authinfo.gpg=:

  1. Create a plaintext =~/.authinfo= file
  2. Place authentication credentials - an example for =magit=
     #+begin_src text
       machine api.github.com login <github-username>^forge password <api-token>
     #+end_src
  3. Use emacs' "EasyPG" to encrypt the file with my gpg key and save it as =~/.authinfo.gpg= - =M-x epa-encrypt-file=
  4. Remove the plaintext =~/.authinfo=

  #+begin_src emacs-lisp
    (setq auth-sources '("~/.authinfo.gpg"))
  #+end_src

* Auto-save and Backups Behavior

** Centralize auto-save and backup locations

  I like to keep all of Emacs' auto-generated saves and backups tidily
  in a central place rather than littering the filesystem. Here I tell
  emacs to redirect the generated files to a known directory when it
  auto-saves.

  #+BEGIN_SRC emacs-lisp
    (make-directory "~/.emacs.d/autosaves/" t)
    (make-directory "~/.emacs.d/backups/" t)

    (setq auto-save-file-name-transforms
    (quote ((".*" "~/.emacs.d/autosaves/\\1" t))))
    (setq backup-directory-alist
    (quote ((".*" . "~/.emacs.d/backups/"))))
  #+END_SRC

** Centralize =tramp= backups

   For the same reasons as auto-saves and backups, I keep backups from
   Tramp mode in the same centralized location.

   #+BEGIN_SRC emacs-lisp
     (setq tramp-backup-directory-alist backup-directory-alist)
   #+END_SRC

** Enable backups for files under version control

   Just because the file is under version control does not mean I
   don’t care about backups. Lets make sure they are still getting
   backed up.

   #+BEGIN_SRC emacs-lisp
     (setq vc-make-backup-files t)
   #+END_SRC

** Save on lose focus

   When I leave emacs or change a buffer, auto-save all open buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package super-save
       :ensure t
       :init
       (super-save-mode t)
       (setq super-save-auto-save-when-idle t))
   #+END_SRC

* Better scrolling

** Make scrolling smoother and scroll one line at a time

   The default emacs scrolling behavior can be difficult to use; the text
   jumps too much too fast. This should make scrolling a little bit more
   smooth when in GUI emacs.

   #+BEGIN_SRC emacs-lisp
     (when window-system
       (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
       (setq mouse-wheel-progressive-speed nil)
       (setq mouse-wheel-follow-mouse 't)
       (setq scroll-step 1))
   #+END_SRC

* Syntax checking

  I generally find checking syntax and structure useful, and flycheck
  does this well, and has many plugins that I can enable in other
  modes, so lets make sure it is installed and enabled here.

  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :init
      (add-hook 'after-init-hook #'global-flycheck-mode)
      :config
      (setq-default flycheck-disabled-checkers (append flycheck-disabled-checkers '(javascript-jshint)))
      (flycheck-add-mode 'javascript-eslint 'js-mode)
      (flycheck-add-mode 'javascript-eslint 'js2-mode)
      (flycheck-add-mode 'javascript-eslint 'rjsx-mode)
      (setq flycheck-javascript-eslint-executable "node_modules/.bin/eslint")
      (setq flycheck-ruby-rubocop-executable "bin/rubocop"))
  #+END_SRC

* Spell Checking

  I am prone to typos. Enable flyspell in textual contexts to help
  catch the times where I don't quite English so well.

  #+BEGIN_SRC emacs-lisp
    (use-package flyspell
      :diminish flyspell-mode
      :commands (flyspell-prog-mode flyspell-mode)
      :init
      (if (string-equal system-type "darwin") (setq ispell-program-name "/usr/local/bin/aspell"))
      (add-hook 'ruby-mode-hook 'flyspell-prog-mode)
      (add-hook 'markdown-mode-hook 'flyspell-mode)
      (add-hook 'org-mode-hook 'flyspell-mode)
      (add-hook 'text-mode-hook 'flyspell-mode))
  #+END_SRC

* Auto Complete

  I find auto completion allows the speed of my hands to more closely
  match the speed of my brain and avoids typos. I used to use
  =auto-complete=, but a friend has convinced me to try =company-mode=
  so let's give it a shot.

  #+BEGIN_SRC emacs-lisp
    (use-package company
      :bind (:map company-active-map
             ("C-n" . company-select-next)
             ("C-p" . company-select-previous)
             ("C-:" . company-complete))
      :config
      (setq company-idle-delay 0.3)
      (global-company-mode t))

  #+END_SRC

* Agenda

  Furthering the usefulness of =org-mode=, I've started using
  =org-agenda= to organize my notes, events, etc. My current setup is
  such that =~/org= is a symlink to a directory containing a
  collection of =.org= files for general note taking, task logging,
  scheduling, interview notes, etc. - the target directory of the
  =~/org= symlink is automatically synced between all of my hosts.

  #+begin_src emacs-lisp
    (use-package org-agenda
      :after org
      :bind (("C-c a" . org-agenda)
             :map org-mode-map
             ("C-'" . nil)
             ("C-," . nil))
      :config
      ;; Basic setup
      (setq org-agenda-span 14)
      (setq org-agenda-start-on-weekday 1)  ; Monday
      (setq org-agenda-confirm-kill t)
      (setq org-agenda-show-all-dates t)
      (setq org-agenda-show-outline-path nil)
      (setq org-agenda-window-setup 'current-window)
      (setq org-agenda-skip-comment-trees t)
      (setq org-agenda-menu-show-matcher t)
      (setq org-agenda-menu-two-columns nil)
      (setq org-agenda-sticky nil)
      (setq org-agenda-custom-commands-contexts nil)
      (setq org-agenda-max-entries nil)
      (setq org-agenda-max-todos nil)
      (setq org-agenda-max-tags nil)
      (setq org-agenda-max-effort nil)

      ;; General view options
      (setq org-agenda-prefix-format
            '((agenda . " %i %-12:c%?-12t% s")
              (todo . " %i %-12:c")
              (tags . " %i %-12:c")
              (search . " %i %-12:c")))
      (setq org-agenda-sorting-strategy
            '(((agenda habit-down time-up priority-down category-keep)
               (todo priority-down category-keep)
               (tags priority-down category-keep)
               (search category-keep))))
      (setq org-agenda-breadcrumbs-separator "->")
      (setq org-agenda-todo-keyword-format "%-1s")
      (setq org-agenda-diary-sexp-prefix nil)
      (setq org-agenda-fontify-priorities 'cookies)
      (setq org-agenda-category-icon-alist nil)
      (setq org-agenda-remove-times-when-in-prefix nil)
      (setq org-agenda-remove-timeranges-from-blocks nil)
      (setq org-agenda-compact-blocks nil)
      (setq org-agenda-block-separator ?—)

      (defun prot/org-agenda-format-date-aligned (date)
        "Format a DATE string for display in the daily/weekly agenda.
    This function makes sure that dates are aligned for easy reading.

    Slightly tweaked version of `org-agenda-format-date-aligned' that
    produces dates with a fixed length."
        (require 'cal-iso)
        (let* ((dayname (calendar-day-name date t))
               (day (cadr date))
               (day-of-week (calendar-day-of-week date))
               (month (car date))
               (monthname (calendar-month-name month t))
               (year (nth 2 date))
               (iso-week (org-days-to-iso-week
                          (calendar-absolute-from-gregorian date)))
               (weekyear (cond ((and (= month 1) (>= iso-week 52))
                                (1- year))
                               ((and (= month 12) (<= iso-week 1))
                                (1+ year))
                               (t year)))
               (weekstring (if (= day-of-week 1)
                               (format " (W%02d)" iso-week)
                             "")))
          (format "%s %2d %s %4d%s"
                  dayname day monthname year weekstring)))

      (setq org-agenda-format-date #'prot/org-agenda-format-date-aligned)

      ;; Marks
      (setq org-agenda-bulk-mark-char "#")
      (setq org-agenda-persistent-marks nil)

      ;; Diary entries
      (setq org-agenda-insert-diary-strategy 'date-tree)
      (setq org-agenda-insert-diary-extract-time nil)
      (setq org-agenda-include-diary t)

      ;; Follow mode
      (setq org-agenda-start-with-follow-mode nil)
      (setq org-agenda-follow-indirect t)

      ;; Multi-item tasks
      (setq org-agenda-dim-blocked-tasks t)
      (setq org-agenda-todo-list-sublevels t)

      ;; Filters and restricted views
      (setq org-agenda-persistent-filter nil)
      (setq org-agenda-restriction-lock-highlight-subtree t)

      ;; Items with deadline and scheduled timestamps
      (setq org-agenda-include-deadlines t)
      (setq org-deadline-warning-days 5)
      (setq org-agenda-skip-scheduled-if-done nil)
      (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
      (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
      (setq org-agenda-skip-deadline-if-done nil)
      (setq org-agenda-skip-deadline-prewarning-if-scheduled 1)
      (setq org-agenda-skip-scheduled-delay-if-deadline nil)
      (setq org-agenda-skip-additional-timestamps-same-entry nil)
      (setq org-agenda-skip-timestamp-if-done nil)
      (setq org-agenda-search-headline-for-time t)
      (setq org-scheduled-past-days 365)
      (setq org-deadline-past-days 365)
      (setq org-agenda-move-date-from-past-immediately-to-today t)
      (setq org-agenda-show-future-repeats t)
      (setq org-agenda-prefer-last-repeat nil)
      (setq org-agenda-timerange-leaders
            '("" "(%d/%d): "))
      (setq org-agenda-scheduled-leaders
            '("Scheduled: " "Sched.%2dx: "))
      (setq org-agenda-inactive-leader "[")
      (setq org-agenda-deadline-leaders
            '("Deadline:  " "In %3d d.: " "%2d d. ago: "))
      ;; Time grid
      (setq org-agenda-time-leading-zero t)
      (setq org-agenda-timegrid-use-ampm nil)
      (setq org-agenda-use-time-grid t)
      (setq org-agenda-show-current-time-in-grid t)
      (setq org-agenda-current-time-string
            "Now -·-·-·-·-·-·-")
      (setq org-agenda-time-grid
            '((daily today require-timed)
              (0600 0700 0800 0900 1000 1100
                    1200 1300 1400 1500 1600
                    1700 1800 1900 2000 2100)
              " ....." "-----------------"))
      (setq org-agenda-default-appointment-duration nil)

      ;; Global to-do list
      (setq org-agenda-todo-ignore-with-date t)
      (setq org-agenda-todo-ignore-timestamp t)
      (setq org-agenda-todo-ignore-scheduled t)
      (setq org-agenda-todo-ignore-deadlines t)
      (setq org-agenda-todo-ignore-time-comparison-use-seconds t)
      (setq org-agenda-tags-todo-honor-ignore-options nil)

      ;; Tagged items
      (setq org-agenda-show-inherited-tags t)
      (setq org-agenda-use-tag-inheritance
            '(todo search agenda))
      (setq org-agenda-hide-tags-regexp nil)
      (setq org-agenda-remove-tags nil)
      (setq org-agenda-tags-column -120)

      ;; Agenda entry
      ;;
      ;; NOTE I do not use this right now.  Leaving everything to its
      ;; default value.
      (setq org-agenda-start-with-entry-text-mode nil)
      (setq org-agenda-entry-text-maxlines 5)
      (setq org-agenda-entry-text-exclude-regexps nil)
      (setq org-agenda-entry-text-leaders "    > ")

      ;; Logging, clocking
      ;;
      ;; NOTE I do not use these yet, though I plan to.  Leaving everything to
      ;; its default value for the time being.
      (setq org-agenda-log-mode-items '(closed clock))
      (setq org-agenda-clock-consistency-checks
            '((:max-duration "10:00" :min-duration 0 :max-gap "0:05" :gap-ok-around
                             ("4:00")
                             :default-face ; This should definitely be reviewed
                             ((:background "DarkRed")
                              (:foreground "white"))
                             :overlap-face nil :gap-face nil :no-end-time-face nil
                             :long-face nil :short-face nil)))
      (setq org-agenda-log-mode-add-notes t)
      (setq org-agenda-start-with-log-mode nil)
      (setq org-agenda-start-with-clockreport-mode nil)
      (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2))
      (setq org-agenda-search-view-always-boolean nil)
      (setq org-agenda-search-view-force-full-words nil)
      (setq org-agenda-search-view-max-outline-level 0)
      (setq org-agenda-search-headline-for-time t)
      (setq org-agenda-use-time-grid t)
      (setq org-agenda-cmp-user-defined nil)
      (setq org-sort-agenda-notime-is-late t)
      (setq org-sort-agenda-noeffort-is-high t)

      ;; Agenda column view
      ;;
      ;; NOTE I do not use these, but may need them in the future.
      (setq org-agenda-view-columns-initially nil)
      (setq org-agenda-columns-show-summaries t)
      (setq org-agenda-columns-compute-summary-properties t)
      (setq org-agenda-columns-add-appointments-to-effort-sum nil)
      (setq org-agenda-auto-exclude-function nil)
      (setq org-agenda-bulk-custom-functions nil))
  #+end_src

* Auto Insert

  Automatically insert bits into buffers

  #+begin_src emacs-lisp
    (use-package autoinsert
      :hook ((prog-mode yaml-mode) . auto-insert-mode)
      :config
      (setq auto-insert-query nil)
      (setq auto-insert-alist
            (-cons*
             '("\\.rb$" nil "# frozen_string_literal: true\n")
             auto-insert-alist)))
  #+end_src

  The [[https://marmalade-repo.org/][marmalade repository]]'s been serving a broken certificate for a
  while. For now, instead of relying on the broken repo I'm going to
  tangle the source of the header2 package directly into my
  configuration.
  #+begin_src emacs-lisp
    (use-package header2
      :ensure t
      :defer t
      :disabled t
      :config
      (add-hook 'ruby-mode 'auto-make-header))
  #+end_src

  #+begin_src emacs-lisp
    ;;; header2.el --- Support for creation and update of file headers.
    ;;
    ;; Filename: header2.el
    ;; Description: Support for creation and update of file headers.
    ;; Author: Lynn Slater
    ;;         Drew Adams
    ;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
    ;; Copyright (C) 1996-2019, Drew Adams, all rights reserved.
    ;; Copyright (C) 1989 Free Software Foundation, Inc.
    ;; Copyright (C) 1988 Lynn Randolph Slater, Jr.
    ;; Created: Tue Aug  4 17:06:46 1987
    ;; Version: 0
    ;; Package-Requires: ()
    ;; Last-Updated: Wed Aug 14 07:18:29 2019 (-0700)
    ;;           By: dradams
    ;;     Update #: 2022
    ;; URL: https://www.emacswiki.org/emacs/download/header2.el
    ;; Doc URL: https://emacswiki.org/emacs/AutomaticFileHeaders
    ;; Keywords: tools, docs, maint, abbrev, local
    ;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;
    ;;; Commentary:
    ;;
    ;; Support for creation and update of file headers.
    ;;
    ;; Some of this code and commentary were originally written by Lynn
    ;; Slater as file `header.el'.  Drew Adams updated it and maintains it
    ;; as `header2.el'.  The original is here:
    ;; `https://www.emacswiki.org/emacs/download/OriginalHeaderEl'.
    ;;
    ;; Commands (interactive functions) defined here:
    ;;
    ;;   `make-header', `make-revision', `make-divider',
    ;;   `make-box-comment', `make-box-comment-region',
    ;;   `update-file-header'.
    ;;
    ;; Other functions defined here:
    ;;
    ;;   `auto-make-header', `auto-update-file-header',
    ;;   `delete-and-forget-line', `header-AFS', `header-author',
    ;;   `header-blank', `header-code', `header-commentary',
    ;;   `header-compatibility', `header-copyright',
    ;;   `header-creation-date', `header-date-string',
    ;;   `header-description', `header-doc-url',`header-end-line',
    ;;   `header-eof', `header-file-name', `header-free-software',
    ;;   `header-history', `header-keywords', `header-lib-requires',
    ;;   `header-maintainer', `header-mode-line',
    ;;   `header-modification-author', `header-modification-date',
    ;;   `header-multiline', `header-pkg-requires',
    ;;   `header-prefix-string', `header-rcs-id', `header-rcs-log',
    ;;   `header-sccs', `header-shell', `header-status', `header-title',
    ;;   `header-toc', `header-update-count', `header-url',
    ;;   `header-version', `headerable-file-p', `make-box-comment',
    ;;   `make-divider', `make-revision', `nonempty-comment-end',
    ;;   `nonempty-comment-start', `register-file-header-action',
    ;;   `section-comment-start', `true-mode-name', `uniquify-list',
    ;;   `update-file-name', `update-last-modified-date',
    ;;   `update-last-modifier', `update-lib-requires',
    ;;   `update-write-count'.
    ;;
    ;; User options (variables) defined here:
    ;;
    ;;   `header-copyright-notice', `header-date-format',
    ;;   `header-history-label', `header-max',
    ;;   `make-box-comment-region-replace-prefix-flag',
    ;;   `make-header-hook'.
    ;;
    ;; Other variables defined here:
    ;;
    ;;   `file-header-update-alist', `header-auto-update-enabled',
    ;;   `header-multiline', `header-prefix-string', `return-to'.
    ;;
    ;;
    ;; To have Emacs update file headers automatically whenever you save a
    ;; file, put this in your init file (~/.emacs):
    ;;
    ;;   (autoload 'auto-update-file-header "header2")
    ;;   (add-hook 'write-file-hooks 'auto-update-file-header)
    ;;
    ;; To have Emacs add a file header whenever you create a new file in
    ;; some mode, put this in your init file (~/.emacs):
    ;;
    ;;   (autoload 'auto-make-header "header2")
    ;;   (add-hook 'emacs-lisp-mode-hook 'auto-make-header)
    ;;   (add-hook 'c-mode-common-hook   'auto-make-header)
    ;;   ...
    ;;
    ;;
    ;;
    ;; From the original header.el text by Lynn Slater:
    ;;
    ;;     This file is particularly useful with the file-declarations
    ;;     package also by Lynn Slater.  Read the first 20% of this file
    ;;     to learn how to customize.
    ;;
    ;;     From: eddie.mit.edu!think!ames!indetech.com!lrs (Lynn Slater)
    ;;     To: info-gnu-emacs@prep.ai.mit.edu
    ;;     Subject: Automatic header creation and maintenance
    ;;     Date: Wed, 1 Nov 89 09:33 PST
    ;;
    ;;     Enclosed is code to automatically create and maintain file
    ;;     headers.  This code is cleaner and mush more easily customized
    ;;     than any of my previous header postings.
    ;;
    ;;     New in this release are customizations that allow headers to be
    ;;     created and maintained from the command line.  This is good for
    ;;     projects with some vi die-hards or when headers are being added
    ;;     in mass for the first time.
    ;;
    ;;     Example:
    ;;        cd $EMACS/lisp
    ;;        headers -make *.el
    ;;
    ;;     I have found file headers to be very valuable in project
    ;;     development.  I always know who has been where and how many
    ;;     times they were there.  Most often, I also know what they did.
    ;;     The update count and last modified date are very useful in
    ;;     determining the proper version of a file to use.  I have often
    ;;     thought that it would be easier to integrate patches from
    ;;     individuals to gnu tools such as gcc and g++ if I knew for
    ;;     certain what version of a particular file they were working
    ;;     from.  If all had headers, I would see the update count and
    ;;     date in the "diff -c" output and would be able to find or
    ;;     recreate the file to patch accordingly.
    ;;
    ;;     In this message are three files:
    ;;       header.el - Emacs header functions and instructions
    ;;       headers.1  - Man page for command line headers useage
    ;;       headers    - Shell script for command-line headers.
    ;;
    ;; Text by Lynn Slater, updated as needed:
    ;;
    ;;     Mode-specific headers:
    ;;     ---------------------
    ;;      Not all headers need look alike.  Suppose that you have a unix script mode
    ;;      and want it to have a shell specifier line that all other headers do not
    ;;      have.  To do this, Place the following line in a hook called when the
    ;;      mode is invoked or in the code that establishes the mode:
    ;;
    ;;         (add-hook 'make-header-hook 'header-shell nil t)

    ;;      The header building blocks are sensitive to the different comment
    ;;      characters in different modes.

    ;;     Mode specific update actions:
    ;;     ----------------------------
    ;;      Suppose something needs to be automatically maintained only in certain
    ;;      modes.  An example is the .TH macro in man pages.  You can create mode-
    ;;      specific update actions by placing code like the following in the
    ;;      mode creation function of the mode hook.
    ;;
    ;;        (register-file-header-action
    ;;          "^\.TH[ \t]+[^\" \t]+[ \t]+[^\" \t]+[ \t]+\"\\([^\"]*\\)\""
    ;;         'update-last-modified-date-macro)
    ;;
    ;;     Define individual header elements.  These are the building blocks
    ;;     used to construct a site specific header.  You may add your own
    ;;     functions either in this file or in your `.emacs' file.  The
    ;;     variable `make-header-hook' specifies the functions that will
    ;;     actually be called.
    ;;
    ;; Note on change-control systems:
    ;;
    ;;  If you use `header2.el' in a change-control system, such as RCS,
    ;;  you might need to leave it checked out.  This is because any
    ;;  change-control keywords in the file will be expanded during
    ;;  check-in.  Normally, you will want those keywords to be inserted
    ;;  in file headers unexpanded.
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;
    ;;; Change Log:
    ;;
    ;; 2019/09/13 dadams
    ;;     Cleaned up some code for string vars that might be nil.
    ;; 2016/08/10 dadams
    ;;     Added: make-box-comment-region, make-box-comment-region-replace-prefix-flag
    ;;            (suggestion from Stephen Barrett).
    ;;     make-divider, make-box-comment:
    ;;       Added prefix arg.  Better doc string.  Do not subtract 2 (dunno why it was done).
    ;; 2014/07/23 dadams
    ;;     header-free-software: Updated per latest GNU boilerplate.
    ;; 2014/01/13 dadams
    ;;     Added: nonempty-comment-start, nonempty-comment-end.
    ;;     Removed variables comment-start-p, comment-end-p.
    ;;     header-multiline, header-code, header-eof, header-end-line, header-prefix-string:
    ;;       Use nonempty-comment-end.
    ;;     header-mode-line, header-end-line: Use nonempty-comment-start.
    ;;     make-header: Remove let bindings of comment-start-p, comment-end-p.
    ;; 2013/07/22 dadams
    ;;     Added: header-pkg-requires, for ELPA/package.el.  Added to make-header-hook.
    ;; 2012/08/23 dadams
    ;;     Added: header-doc-url.
    ;;     make-header-hook: Added header-doc-url to default value.
    ;; 2011/12/19 dadams
    ;;     delete-and-forget-line: Use line-end-position, not end-of-line + point.
    ;; 2011/11/15 dadams
    ;;     header-date-string:
    ;;       Use UTC format from http://www.w3.org/TR/NOTE-datetime.  Thx to Lennart Borgman.
    ;; 2011/02/03 dadams
    ;;     Added: header-auto-update-enabled.
    ;;     auto-update-file-header: Respect header-auto-update-enabled.  Thx to Le Wang.
    ;; 2011/01/04 dadams
    ;;     Removed autoload cookies from non-interactive functions.
    ;; 2010/08/03 dadams
    ;;     update-file-name: Use ---, not just -, in title line, per newer standard.
    ;;     make-revision: Escape ; in string, for Emacs 20 (else C-M-q problem).
    ;; 2010/04/12 dadams
    ;;     header-history-label: Change log -> Change Log.
    ;; 2009/10/25 dadams
    ;;     Renamings from lib-require.el.  If you use that library, you must update it.
    ;;       lib-requires-header -> libreq-file-header
    ;;       insert-lib-requires-as-comment -> libreq-insert-lib-requires-as-comment
    ;; 2009/09/24 dadams
    ;;     header-multiline: Use a marker for END, and go to it after insert multiline.
    ;;     header-eof: Go to point-max and insert newline.
    ;; 2008/09/06 dadams
    ;;     update-write-count: Keep rest of line, after number.  Thx to Johan Vromans.
    ;;     Added update-VCS-version, commented out.
    ;; 2008/08/06 dadams
    ;;     header-date-string: Use %z, not %Z - the latter no longer works on Windows.
    ;; 2008/07/11 dadams
    ;;     header-title, header-file-name, header-eof:
    ;;       Use buffer-file-name, if available.  Thx Juan Miguel Cejuela for suggestion.
    ;; 2008/03/14 dadams
    ;;     header-free-software: Update version 2 -> version 3 of GPL.
    ;; 2008/01/18 dadams
    ;;     header-creation-date: Added time zone also.  Thx to Sebastian Luque.
    ;;     Added: header-date-(string|format).
    ;;     header-creation-date, update-last-modified-date: Use header-date-format.
    ;; 2007/12/12 dadams
    ;;     INCOMPATIBLE CHANGE - If you previously used update-file-header as a
    ;;                           write-file-hook, change it to auto-update-file-header.
    ;;     Added auto-update-file-header.  Uses new update-file-header.
    ;;     update-file-header: Made unconditional.  Thx to Lennart Borgman.
    ;; 2007/03/25 dadams
    ;;     make-header: Use let*, so comment-end-p is bound in header-prefix-string.
    ;; 2006/01/13 dadams
    ;;     Added: header-url.
    ;; 2006/01/07 dadams
    ;;     Added :link.
    ;; 2005/11/04 dadams
    ;;     update-last-modified-date: Added timezone.
    ;; 2005/10/21 dadams
    ;;     Added header-free-software, header-multiline (vars & fns).
    ;;     Updated make-header-hooks.
    ;;     update-lib-requires:
    ;;       Use error msg if insert-lib-requires-as-comment errors.
    ;;       Made buffer-file-name filter outermost.
    ;;       Got rid of locate-library filter.
    ;;     header-code, header-eof: Include comment-end case.
    ;;     Changed defvar to defcustom.
    ;;     auto-make-header: Make sure its a file buffer.
    ;;     Protect lib-requires-header with boundp.
    ;;     Renamed make-header-hooks to make-header-hook.
    ;;     Cleaned up Commentary.  Added .emacs instructions, note on change control.
    ;;     header-prefix-string: Don't bother to bind comment-end-p.
    ;; 2005/10/19 dadams
    ;;     Increased header max default value from 2000 to 50000.
    ;; 2005/10/18 dadams
    ;;     Added: update-lib-requires, header-lib-requires, header-version.
    ;;     make-header-hooks:
    ;;       Use header-version, not header-rcs-id.  Use header-lib-requires.
    ;;       Don't use header-rcs-log.
    ;;     update-last-modifier: inlined code for non-empty-name-p.
    ;;     Require lib-requires.el.
    ;; 2004/10/01 dadams
    ;;     auto-make-header: not if read-only
    ;;     header-rcs-log: Split string so it won't be overwritten by vc.el
    ;;       Thanks to Steve Taylor for this fix.
    ;; 2004/06/04 dadams
    ;;     header-eof: Removed "`" and "'" around file name.
    ;; 1996/04/04 dadams
    ;;     Mods for modes like C, etc.
    ;;     1. make-header-hooks: Removed header-blank before: header-commentary,
    ;;        header-history and header-code.  Added 2 header-blank's after
    ;;        header-commentary.
    ;;     2. Added section-comment-start.
    ;;     3. header-file-name: Only use header-prefix-string if 1-char comment-start.
    ;;     4. header-commentary,header-history,header-code: Use section-comment-start.
    ;;     5. header-code: Only add ":\n\n\n\n\n" if 1-char comment-start.
    ;;     6. header-eof: Removed extra " ".
    ;; 1996/03/18 dadams
    ;;     Added defvars for return-to, explicit-shell-file-name, c-style .
    ;; 1996/02/12 dadams
    ;;     Added auto-make-header.
    ;; 1995/09/04 dadams
    ;;     Adapted to std GNU maintenance form (see file lisp-mnt.el).
    ;;     1) Distinguished sections from subsections.  Changed order.
    ;;     2) No longer use header-mode-line (conflicts with GNU maintenance std).
    ;;     3) Added header-eof, header-history-label.
    ;;     4) Removed header-purpose (use just header-commentary).
    ;;     5) Redefined: make-revision, header-file-name, header-history,
    ;;        header-rcs-id, header-sccs, header-copyright.
    ;; 1995/08/08 dadams
    ;;     Added header-maintainer, header-keywords, header-commentary, header-code.
    ;; 1995/08/02 dadams
    ;;     header-rcs -> header-rcs-id, header-rcs-log, and changed order.
    ;; 1995/07/31 dadams
    ;;     1. Corrected SCCS & RCS strings (need to be uninstantiated here).\
    ;;     2. Added defvar for header-prefix-string (not really needed).
    ;;     3. Commented out stuff that needs Lynn Slater's command-line-hooks.
    ;; 28-Apr-1995 dadams
    ;;     Added default for comment-start in make-revision.
    ;; 11/11/89 -- Darryl Okahata, HP NMD (darrylo%hpnmd@hpcea.HP.COM)
    ;; 25-Sep-1989          Lynn Slater
    ;;    added -default-mode ahd headerable-file-p
    ;; 10-Sep-1989          Lynn Slater
    ;;    Seperated out header-mode-line and header-end.  Headers are now really
    ;;    easy to modify.  Added instructions for mode-specific headers.
    ;; 8-Aug-1989           Lynn Slater
    ;;    Changed structure to allow site/user customized headers
    ;; 24-Jun-1989          Lynn Slater
    ;;    restructured file, made the order of header actions not be significant.
    ;; 22-Jun-1989          Lynn Slater
    ;;    Made file header actions easier to declare
    ;;    Made sccs and rcs support be user settable.
    ;;    Added c-style support
    ;; 25-Jan-1989          Lynn Slater
    ;;    Added make-doc command
    ;; 25-Jan-1989          Lynn Slater
    ;;    made the make-revision command include the last-modified data
    ;; 31-Aug-1988          Lynn Slater
    ;;    Made the make-revision work in most modes
    ;;    Added the update-file-name command
    ;; 1-Mar-1988           Lynn Slater
    ;;   made the headers be as sensitive as possible to the proper
    ;;   comment chars.
    ;; 1-Mar-1988           Lynn Slater
    ;;   Made the mode be declared in each header
    ;; 26-Feb-1988          Lynn Slater
    ;;   added the make-revision call
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;
    ;; This program is free software; you can redistribute it and/or modify
    ;; it under the terms of the GNU General Public License as published by
    ;; the Free Software Foundation; either version 3, or (at your option)
    ;; any later version.

    ;; This program is distributed in the hope that it will be useful,
    ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
    ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    ;; GNU General Public License for more details.

    ;; You should have received a copy of the GNU General Public License
    ;; along with this program; see the file COPYING.  If not, write to
    ;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
    ;; Floor, Boston, MA 02110-1301, USA.
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;
    ;;; Code:

    (require 'lib-requires nil t)
      ;; (no error if not found):
      ;; libreq-insert-lib-requires-as-comment, libreq-file-header

    ;;;;;;;;;;;;;;;;;;;;;;

    (provide 'header2)
    (require 'header2)                      ; Ensure loaded before compile.


    ;; Quiet byte-compiler.
    (defvar c-style)
    (defvar explicit-shell-file-name)
    (defvar libreq-file-header)

    ;; User Options (Variables) --------------------------------

    (defgroup Automatic-File-Header nil
      "File header insertion and updating."
      :group 'files :group 'editing :group 'convenience :group 'programming
      :group 'development
      :link `(url-link :tag "Send Bug Report"
              ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
    header2.el bug: \
    &body=Describe bug here, starting with `emacs -q'.  \
    Don't forget to mention your Emacs and library versions."))
      :link '(url-link :tag "Other Libraries by Drew"
              "https://www.emacswiki.org/emacs/DrewsElispLibraries")
      :link '(url-link :tag "Download"
              "https://www.emacswiki.org/emacs/download/header2.el")
      :link '(url-link :tag "Description"
              "https://www.emacswiki.org/emacs/AutomaticFileHeaders#header2")
      :link '(emacs-commentary-link :tag "Commentary" "header2")
      )

    (defcustom header-max 50000
      "*Maximum number of chars to examine for header updating."
      :type 'integer :group 'Automatic-File-Header)

    (defcustom header-copyright-notice nil
      "*Copyright notice to be inserted into file headers."
        :type '(choice (const :tag "No copyright notice (value nil)" nil) string)
        :group 'Automatic-File-Header)

    (defcustom header-date-format t
      "*Date/time format for header timestamp.
    The value can be a string, t, or nil.
    A string value is passed to `format-time-string'.
    t means use local time with timezone; nil means use UTC."
      :group 'Automatic-File-Header
      :type '(choice
              (const  :tag "Local time, with timezone" t)
              (const  :tag "UTC" nil)
              (string :tag "Custom format")))

    ;; Change this as you like.
    ;; Note that the Elisp manual, node Library Headers, suggests putting copyright just
    ;; after header-description.  That is not done here, by default, because I feel that
    ;; copyright is not the first information people are looking for.  Otherwise, this
    ;; default value corresponds to what the Elisp manual recommends for Emacs Lisp.
    (defcustom make-header-hook '(
                                  ;;header-mode-line
                                  header-title
                                  header-blank
                                  header-file-name
                                  header-description
                                  ;;header-status
                                  header-author
                                  header-maintainer
                                  header-copyright
                                  header-creation-date
                                  ;;header-rcs-id
                                  header-version
                                  header-pkg-requires
                                  ;;header-sccs
                                  header-modification-date
                                  header-modification-author
                                  header-update-count
                                  header-url
                                  header-doc-url
                                  header-keywords
                                  header-compatibility
                                  header-blank
                                  header-lib-requires
                                  header-end-line
                                  header-commentary
                                  header-blank
                                  header-blank
                                  header-blank
                                  header-end-line
                                  header-history
                                  header-blank
                                  header-blank
                                  ;; header-rcs-log
                                  header-end-line
                                  header-free-software
                                  header-code
                                  header-eof
                                  )
      "*Functions that insert header elements.
    Each function is started on a new line and is expected to end in a new line.
    Each function may insert any number of lines, but each line, including the
    first, must be started with the value of `header-prefix-string'.
    \(This variable holds the same value as would be returned by calling
    `header-prefix-string' but is faster to access.)  Each function may set the
    following global variables:

      `header-prefix-string' -- mode-specific comment sequence
      `return-to' -- character position to which point will be moved after header
                     functions are processed.  Any header function may set this,
                     but only the last setting will take effect.

    It is reasonable to locally set these hooks according to certain modes.
    For example, a table of contents might only apply to code development modes
    and `header-shell' might only apply to shell scripts.  See instructions in
    file `header2.el' to do this."
      :type 'hook :group 'Automatic-File-Header)

    (defcustom header-history-label "Change Log:" ; Was "HISTORY:" before.
      "*Label introducing change log history."
      :type 'string :group 'Automatic-File-Header)

    (defcustom header-free-software
      "This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or (at
    your option) any later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>."

      "*Text saying that this is free software"
      :type 'string :group 'Automatic-File-Header)

    (defcustom make-box-comment-region-replace-prefix-flag nil
      "Non-nil means remove any comment prefix from lines, before boxing."
      :type 'boolean :group 'Automatic-File-Header)

    ;;; Internal variables -------------------------------------

    (defvar header-auto-update-enabled t
      "Non-nil means file-header updating is enabled for current buffer.")

    (make-variable-buffer-local 'header-auto-update-enabled)
    (when (boundp 'safe-local-variable-values)
      (add-to-list 'safe-local-variable-values '(header-auto-update-enabled)))

    (defvar return-to nil
      "Position to move point to after header fns are processed.
    Any header function may set this.  The last setting will take effect.")

    (defvar header-multiline ""
      "Multiline text to be inserted as a comment.
    Leave the global value of this as \"\", and bind the value as needed.")

    (defvar file-header-update-alist ()
      "Used by `update-file-header' to know what to do in a file.
    Is a list of sets of cons cells where the car is a regexp string and the cdr is
    the function to call if the string is found near the start of the file.")

    (defvar header-prefix-string ""
      "Mode-specific comment prefix string for use in headers.")

    ;;; Functions ----------------------------------------------

    (defsubst nonempty-comment-start ()
      "Return `comment-start', or nil if it is an empty string."
      (and (not (equal "" comment-start))  comment-start))

    (defsubst nonempty-comment-end ()
      "Return `comment-end', or nil if it is an empty string."
      (and (not (equal "" comment-end))  comment-end))

    (defsubst header-blank ()
      "Insert `header-prefix-string' followed by a newline char."
      (insert (concat header-prefix-string "\n")))

    ;; Major section headings

    (defsubst section-comment-start ()
      "Comment start of major section headings."
      (if (= (length comment-start) 1)      ; e.g. Lisp: ";; \n;;;"
          (concat header-prefix-string "\n" comment-start header-prefix-string)
        (concat "\n" comment-start)))       ; e.g. C: "\n/*"

    (defsubst header-title ()
      "Insert buffer's file name and leave room for a description.
    In `emacs-lisp-mode', this should produce the title line for library
    packages."
      (insert (concat comment-start
                      (and (= 1 (length comment-start))  header-prefix-string)
                      (if (buffer-file-name)
                          (file-name-nondirectory (buffer-file-name))
                        (buffer-name))
                      " --- " "\n"))
      (setq return-to  (1- (point))))

    (defsubst header-file-name ()
      "Insert \"Filename: \" line, using buffer's file name."
      (insert (concat header-prefix-string
                      "Filename: "
                      (if (buffer-file-name)
                          (file-name-nondirectory (buffer-file-name))
                        (buffer-name))
                      "\n")))

    (defsubst header-description ()
      "Insert \"Description: \" line."
      (insert (concat header-prefix-string "Description: \n")))

    (defsubst header-author ()
      "Insert current user's name (`user-full-name') as this file's author."
      (insert (concat header-prefix-string "Author: " (user-full-name) "\n")))

    (defsubst header-maintainer ()
      "Insert \"Maintainer: \" line."
      (insert (concat header-prefix-string "Maintainer: \n")))

    (defun header-copyright ()
      "Insert `header-copyright-notice', unless nil."
      (when header-copyright-notice
        (let ((start  (point)))
          (insert header-copyright-notice)
          (save-restriction
            (narrow-to-region start (point))
            (goto-char (point-min))
            ;; Must now insert header prefix.  Cannot just replace string,
            ;; because that would cause too many undo boundries.
            (insert (concat header-prefix-string))
            (while (progn (skip-chars-forward "^\n") (looking-at "\n"))
              (forward-char 1) (unless (eolp) (insert (concat header-prefix-string))))
            (goto-char (point-max))))))

    (defsubst header-creation-date ()
      "Insert today's time, date, and time zone as file creation date."
      (insert (concat header-prefix-string "Created: "))
      (insert (header-date-string) "\n"))

    (defun header-date-string ()
      "Current date and time."
      (format-time-string
       (cond ((stringp header-date-format) header-date-format)
             (header-date-format "%a %b %e %T %Y (%z)")
             (t                  "%Y-%m-%dT%T%z")) ; An alternative: "%a %b %e %T %Y (UTC)"
       (current-time)
       (not header-date-format)))

    (defsubst header-rcs-id ()
      "Insert lines to record RCS id information (\"$Id$\n\")."
      (insert (concat header-prefix-string "Version: $Id$\n")))

    (defsubst header-version ()
      "Insert lines to record version information."
      (insert (concat header-prefix-string "Version: \n")))

    (defsubst header-sccs ()
      "Insert a line to record SCCS version information."
      (insert (concat header-prefix-string "Version: %W%    %E%    %U%\n")))

    (defsubst header-pkg-requires ()
      "Insert a line to record `Package-Requires' information."
      (insert (concat header-prefix-string "Package-Requires: ()\n")))

    (defsubst header-commentary ()
      "Insert \"Commentary: \" line."
      (insert (concat (section-comment-start) "Commentary: \n")))

    (defsubst header-history ()
      "Insert `header-history-label' into header for use by `make-revision'.
    Without this, `make-revision' inserts `header-history-label' after the header."
      (insert (concat (section-comment-start) header-history-label "\n")))

    (defun header-free-software ()
      "Insert text saying that this is free software."
      (let ((header-multiline  header-free-software)) (header-multiline)))

    (defun header-multiline ()
      "Insert multiline comment.  The comment text is in `header-multiline'."
      (when header-multiline
        (let ((lineno  1)
              beg end nb-lines)
          (beginning-of-line)
          (if (nonempty-comment-end)
              (insert (concat "\n" comment-start))
            (header-blank)
            (insert (concat header-prefix-string)))
          (setq beg  (point))
          (insert header-multiline)
          (setq end       (point-marker)
                nb-lines  (count-lines beg end))
          (goto-char beg)
          (forward-line 1)
          (while (< lineno nb-lines)
            (insert (concat header-prefix-string))
            (forward-line 1)
            (setq lineno  (1+ lineno)))
          (goto-char end)
          (when (nonempty-comment-end) (insert "\n"))
          (insert (concat comment-end))
          (insert "\n")
          (unless (nonempty-comment-end)
            (header-blank)
            (header-end-line)))))

    (defsubst header-code ()
      "Insert \"Code: \" line."
      (insert (concat (section-comment-start) "Code:" (nonempty-comment-end) "\n\n\n")))

    (defsubst header-eof ()
      "Insert comment indicating end of file."
      (goto-char (point-max))
      (insert "\n")
      (unless (nonempty-comment-end) (header-end-line))
      (insert (concat comment-start
                      (and (= 1 (length comment-start))  header-prefix-string)
                      (if (buffer-file-name)
                          (file-name-nondirectory (buffer-file-name))
                        (buffer-name))
                      " ends here"
                      (or (nonempty-comment-end)  "\n"))))

    (defsubst header-modification-date ()
      "Insert todays date as the time of last modification.
    This is normally overwritten with each file save."
      (insert (concat header-prefix-string "Last-Updated: \n")))

    (defsubst header-modification-author ()
      "Insert current user's name as the last person who modified the file.
    This is normally overwritten with each file save."
      (insert (concat header-prefix-string "          By: \n")))

    (defsubst header-update-count ()
      "Insert a count of the number of times the file has been saved."
      (insert (concat header-prefix-string "    Update #: 0\n")))

    (defsubst header-url ()
      "Insert \"URL: \" line."
      (insert (concat header-prefix-string "URL: \n")))

    (defsubst header-doc-url ()
      "Insert \"Doc URL: \" line."
      (insert (concat header-prefix-string "Doc URL: \n")))

    (defsubst header-keywords ()
      "Insert \"Keywords: \" line."
      (insert (concat header-prefix-string "Keywords: \n")))

    (defsubst header-compatibility ()
      "Insert a \"Compatibility: \" line."
      (insert (concat header-prefix-string "Compatibility: \n")))

    (defsubst header-lib-requires ()
      "Insert list of libraries required by this one."
      (when (and (eq major-mode 'emacs-lisp-mode)  (boundp 'libreq-file-header))
        (insert libreq-file-header)         ; Defined in `lib-requires.el'.
        (insert ";;   None\n;;\n")))

    (defsubst header-status ()
      "Insert a \"Status: \" line."
      (insert (concat header-prefix-string "Status: \n")))

    (defsubst header-toc ()
      "Insert a \"Table of Contents: \" line."
      (insert
       (concat header-prefix-string "Table of Contents: \n" header-prefix-string "\n")))

    (defsubst header-rcs-log ()
      "Insert lines to record RCS log information (\"$Log$\n\")."
      (insert (concat header-prefix-string
                       "RCS $"  ; String split prevents `vc.el' overwrite.
                       "Log$\n")))           ; Thanks to Steve Taylor.

    (defsubst header-AFS ()
      "Insert a line to record SHAPE information."
      (insert (concat header-prefix-string "AFSID: $__Header$\n")))

    (defsubst header-shell ()
      "Insert a kernal shell specifier line.
    Uses the same shell named in `explicit-shell-file-name', the ESHELL
    environment variable, the SHELL environment variable, or
    '/bin/sh'.  (This is the same shell that the shell command uses.)"
      (insert "#!" (or (and (boundp 'explicit-shell-file-name)  explicit-shell-file-name)
                       (getenv "ESHELL")
                       (getenv "SHELL")
                       "/bin/sh")
              "\n"))

    (defun header-mode-line ()
      "Insert a \" -*- Mode: \" line."
      (let* ((mode-declaration  (concat " -*- Mode: " (true-mode-name)
                                        (if (assoc 'c-style (buffer-local-variables))
                                            (concat "; C-Style: " (symbol-name c-style))
                                          "")
                                        " -*- "))
             (md-length         (length mode-declaration)))
        (insert (cond ((and comment-start  (= 1 (length comment-start)))
                       ;; Assume comment start char is also fill char.
                       (concat comment-start comment-start
                               (make-string (/ (- 77 md-length) 2)
                                            (aref comment-start 0))
                               mode-declaration
                               (make-string (/ (- 78 md-length) 2)
                                            (aref comment-start 0))))
                      ((nonempty-comment-start) ; Assume spaces fill the gaps.
                       (concat comment-start
                               (make-string (/ (- 79 md-length (length comment-start)) 2)
                                            ?\ )
                               mode-declaration))
                      (t                    ; No comment-start.  Assume Lisp.
                       (concat ";;" (make-string (/ (- 77 md-length) 2) ?\;)
                               mode-declaration
                               (make-string (/ (- 78 md-length) 2) ?\;))))
                "\n")))

    (defsubst header-end-line ()
      "Insert a divider line."
      (insert (cond ((nonempty-comment-end))
                    ((and comment-start  (= 1 (length comment-start)))
                     (make-string 70 (aref comment-start 0)))
                    ((nonempty-comment-start))
                    (t (make-string 70 ?\;)))
              "\n"))


    ;; User function to declare header actions on a save file.
    ;;   See examples at the end of this file.
    ;; Invoke from `site-init.el' or in `.emacs'.
    ;; -------------------------------------------------------
    (defun register-file-header-action (regexp function-to-call)
      "Record FUNCTION-TO-CALL as the action to take if REGEXP is found
    in the file header when a file is written.  The function will be called
    with the cursor located just after the matched REGEXP.  Calling this twice
    with the same args overwrites the previous FUNCTION-TO-CALL."
      (let ((ml  (assoc regexp file-header-update-alist)))
        (if ml
            (setcdr ml function-to-call);; overwrite old defn
          ;; This entry is new to us.  Add to the master alist
          (setq file-header-update-alist  (cons (cons regexp function-to-call)
                                                file-header-update-alist)))))


    ;; Register the automatic actions to take for file headers during a save
    ;; See the second part of the file for explanations.
    ;; ---------------------------------------------------------------------
    ;; (register-file-header-action "^.* *\\(.*\\) *\\-\\-" 'update-file-name)
    ;; (register-file-header-action "\$VERSION[ \t]*=[ \t]*\"\\([0-9]+\\.\\)+"
    ;;                              'update-write-count)

    (register-file-header-action "Last-Updated[ \t]*: " 'update-last-modified-date)
    (register-file-header-action "          By[ \t]*: " 'update-last-modifier)
    (register-file-header-action "    Update #[ \t]*: " 'update-write-count)
    (when (boundp 'libreq-file-header)
      (register-file-header-action libreq-file-header 'update-lib-requires))


    ;; Header and file division header creation code
    ;; ---------------------------------------------
    (defun true-mode-name ()
      "Return name of mode in a form such that mode may be re-established
    by calling the function named by appending \"-name\" to this string.
    This differs from variable `mode-name' in that this is guaranteed to
    work even when the value has embedded spaces or other junk."
      (let ((major-mode-name  (symbol-name major-mode)))
        (capitalize (substring major-mode-name 0 (or (string-match "-mode" major-mode-name)
                                                     (length major-mode-name))))))

    (defun header-prefix-string ()
      "Return a mode-specific prefix string for use in headers.
    It is sensitive to language-dependent comment conventions."
      (cond
       ;; E.g. Lisp.
       ((and comment-start  (= 1 (length comment-start)))
        (concat comment-start comment-start " "))

       ;; E.g. C++ and ADA.
       ;; Special case, three letter `comment-start' where the first and
       ;; second letters are the same.
       ((and comment-start  (= 3 (length comment-start))
             (equal (aref comment-start 1) (aref comment-start 0)))
        comment-start)

       ;; E.g. C.
       ;; Other three-letter `comment-start' -> grab the middle character
       ((and comment-start  (= 3 (length comment-start)))
        (concat " " (list (aref comment-start 1)) " "))

       ((and comment-start  (not (nonempty-comment-end)))
        ;; Note: no comment end implies full `comment-start' must be used on each line.
        comment-start)
       (t ";; ")))       ; Use Lisp as default.

    ;; Usable as a programming language mode hook.
    (defun auto-make-header ()
      "Call `make-header' if current buffer is empty and is a file buffer."
      (and (zerop (buffer-size))
           (not buffer-read-only)
           (buffer-file-name)
           (make-header)))

    ;;;###autoload
    (defun make-header ()
      "Insert (mode-dependent) header comment at beginning of file.
    A header is composed of a mode line, a body, and an end line.  The body is
    constructed by calling the functions in `make-header-hook'.  The mode line
    and end lines start and terminate block comments.  The body lines continue
    the comment."
      (interactive)
      (beginning-of-buffer)                 ; Leave mark at old location.
      (let* ((return-to             nil)    ; To be set by `make-header-hook'.
             (header-prefix-string  (header-prefix-string))) ; Cache result.
        (mapcar #'funcall make-header-hook)
        (when return-to (goto-char return-to))))

    ;;;###autoload
    (defun make-revision ()
      "Prepare for a new history revision.  Insert history line if inexistant."
      (interactive)
      (setq comment-start  (or comment-start  "\;")) ; Use Lisp comment as default.
      (let ((header-prefix-string   (header-prefix-string))
            (logical-comment-start  (if (= 1 (length comment-start))
                                        (concat comment-start comment-start " ")
                                      comment-start)))
        ;; Look for the history line
        (beginning-of-buffer)               ; Leave a mark behind.
        (if (re-search-forward (concat "^\\(" (and comment-start  (regexp-quote comment-start))
                                       (regexp-quote (header-prefix-string)) "\\|"
                                       (if (nonempty-comment-start)
                                           (concat "\\|" (regexp-quote comment-start))
                                         "")
                                       "\\)" " *\\(" header-history-label
                                       "\\|HISTORY\\)") ; Backward compatibility.
                               header-max t)
            (end-of-line)
          ;; We did not find a history line, add one
          (goto-char (point-min))
          ;; find the first line that is not part of the header
          (while (and (< (point) header-max)
                      (looking-at (concat "[ \t]*\\("
                                          (regexp-quote (header-prefix-string))
                                          (if (nonempty-comment-start)
                                              (concat "\\|" (regexp-quote comment-start))
                                            "")
                                          (if (nonempty-comment-end)
                                              (concat "\\|" (regexp-quote comment-end))
                                            "")
                                          "\\)")))
            (forward-line 1))
          (insert "\n" logical-comment-start header-history-label)
          (save-excursion (insert (concat "\n" comment-end))))
        ;; We are now on the line with the header-history-label label
        (insert (concat "\n"
                        header-prefix-string
                        (let ((str  (current-time-string)))
                          (concat (if (equal ?\  (aref str 8))
                                      (substring str 9 10)
                                    (substring str 8 10))
                                  "-"
                                  (substring str 4 7)
                                  "-"
                                  (substring str 20 24)))
                        "    "
                        (user-full-name)
                        ;;"  |>Ident<|\n"
                        "  \n"
                        header-prefix-string
                        "   "))
        ;; Add details about the history of the file before its modification
        (when (save-excursion (re-search-backward "Last-Updated[ \t]*: \\(.+\\)$" nil t))
          (insert "Last-Updated: " (buffer-substring (match-beginning 1) (match-end 1)))
          (when (save-excursion (re-search-backward "    Update #[ \t]*: \\([0-9]+\\)$" nil t))
            (insert " #" (buffer-substring (match-beginning 1) (match-end 1))))
          (when (save-excursion (re-search-backward "          By[ \t]*: \\(.+\\)$" nil t))
            (insert " (" (buffer-substring (match-beginning 1) (match-end 1)) ")"))
          (insert (concat "\n" header-prefix-string "   ")))))

    ;;;###autoload
    (defun make-divider (&optional end-col)
      "Insert a comment divider line: the comment start, filler, and end.
    The width is `fill-column', by default.  With a numeric prefix arg,
    use that as the width, except use at least 4 columns."
      (interactive "P")
      (setq end-col  (if end-col (prefix-numeric-value end-col) fill-column))
      (insert (concat comment-start))
      (when (= 1 (length comment-start)) (insert comment-start))
      (insert (concat (make-string (max 2 (- end-col (length comment-end) (current-column)))
                                   (aref comment-start (if (= 1 (length comment-start)) 0 1)))
                      comment-end
                      "\n")))

    ;;;###autoload
    (defun make-box-comment (&optional end-col)
      "Insert an empty (mode dependent) box comment.
    The maxium width is `fill-column', by default.  With a numeric prefix
    arg, use that as the maximum width, except use at least 2 + the length
    returned by function `header-prefix-string'."
      (interactive "P")
      (setq end-col  (if end-col (prefix-numeric-value end-col) fill-column))
      (unless (= 0 (current-column)) (forward-line 1))
      (insert (concat comment-start))
      (when (= 1 (length comment-start)) (insert comment-start))
      (unless (char-equal (preceding-char) ?\  ) (insert ?\  ))
      (insert (concat (make-string (max 2 (- end-col (length comment-end) (current-column)))
                                   (aref comment-start (if (= 1 (length comment-start)) 0 1))))
              "\n"
              (header-prefix-string))
      (save-excursion
        (insert
         (concat "\n"
                 (header-prefix-string)
                 (make-string (max 2 (- end-col (length comment-end) (current-column)))
                              (aref comment-start (if (= 1 (length comment-start)) 0 1)))
                 comment-end
                 "\n"))))

    (defun make-box-comment-region (&optional end-col start end)
      "Wrap active region in a box comment, or make an empty box comment.
    The maxium width is `fill-column', by default.  With a numeric prefix
    arg, use that as the maximum width, except use at least 2 + the length
    returned by function `header-prefix-string'.
    Respects `make-box-comment-region-remove-comments'."
      (interactive "P\nr")
      (setq end-col  (if end-col (prefix-numeric-value end-col) fill-column))
      (if (not (and mark-active  (mark)  (> (region-end) (region-beginning))))
          (make-box-comment end-col)
        (let ((selection  (buffer-substring start end)))
          (kill-region start end)
          (make-box-comment end-col)
          (insert
           (replace-regexp-in-string "\n"
                                     (concat "\n" (header-prefix-string))
                                     (if make-box-comment-region-replace-prefix-flag
                                         (replace-regexp-in-string
                                          (concat "^[ \t]*[" (nonempty-comment-start) "]*")
                                          ""
                                          selection)
                                       selection))))))



    ;; Automatic Header update code
    ;; ----------------------------
    ;;;###autoload
    (defun update-file-header ()
      "Update file header.
    Search the first `header-max' chars in buffer using regexps in
    `file-header-update-alist'.  When a match is found, apply the
    corresponding function with point located just after the match.
    The functions can use `match-beginning' and `match-end' to find
    the strings that cause them to be invoked."
      (interactive)
      (save-excursion
        (save-restriction                   ; Only search `header-max' chars.
          (narrow-to-region 1 (min header-max (1- (buffer-size))))
          (let ((patterns  file-header-update-alist))
            ;; Do not record this call as a command in command history.
            (setq last-command  nil)
            (while patterns
              (goto-char (point-min))
              (when (re-search-forward (car (car patterns)) nil t)
                ;; Position cursor at end of match.
                (goto-char (match-end 0))
                ;;(message "do %s" (car patterns)) (sit-for 1)
                (funcall (cdr (car patterns))))
              (setq patterns  (cdr patterns)))))))

    (defun auto-update-file-header ()
      "Update file header if buffer is modified.
    Call `update-file-header' if all of these are true:
     ,* `header-auto-update-enabled' is non-nil,
     ,* the buffer is longer than 100 chars,
     ,* the buffer is modified,
     ,* the buffer is not read-only.
    Return nil, for use on a hook."
      (and header-auto-update-enabled
           (> (buffer-size) 100)
           (buffer-modified-p)
           (not buffer-read-only)
           (update-file-header)
           nil))



    ;; Define individual file header actions.  These are the building
    ;; blocks of automatic header maintenance.
    ;; -----------------------------------------------------------------------
    (defsubst delete-and-forget-line ()
      "Delete current line and return it.  Do not add it to the `kill-ring'."
      (let* ((start  (point))
             (stop   (line-end-position))
             (str    (buffer-substring start stop)))
        (delete-region start stop)
        str))

    (defun update-write-count ()
      (let* ((str  (delete-and-forget-line))
             (rem  (read-from-string str))
             (num  (car rem)))
        (if (numberp num)
            (insert (format "%s" (1+ num)) (substring str (cdr rem)))
          (insert str)
          (error "Invalid number for update count `%s'" str))))

    ;;; ;;;###autoload
    ;;; (defun update-VCS-version ()
    ;;;   "Update VCS version, of the form $VERSION = \"NUM\".
    ;;; NUM is a decimal number with one or more decimal points -
    ;;; e.g. 3.1415.9265.  Only the part after the last decimal point is
    ;;; incremented."
    ;;;   (interactive)
    ;;;   (let* ((beg  (point))
    ;;;          (eol  (line-end-position))
    ;;;          (end  (re-search-forward "\\([^\\\"]+\\)\"" eol t))
    ;;;          (str  (buffer-substring beg (1- end)))
    ;;;          (num  (car (condition-case err
    ;;;                         (read-from-string str)
    ;;;                       (error (format "Invalid number for version `%s'" str))))))
    ;;;     (when (>= num most-positive-fixnum)
    ;;;       (error "Version number is too large to increment: `%s'" num))
    ;;;     (when (and end  (numberp num))
    ;;;       (let ((newnum  (condition-case err2
    ;;;                          (1+ num)
    ;;;                        (error (format "Invalid number for version `%s'" str)))))
    ;;;         (replace-match (format "%d" newnum) nil nil nil 1)))))

    (defsubst update-last-modifier ()
      "Update the line that indicates who last modified the file."
      (delete-and-forget-line)
      (insert (format "%s" (let ((ufn  (user-full-name)))
                             (if (and ufn  (not (string= "" ufn))) ufn (user-login-name))))))

    (defsubst update-last-modified-date ()
      "Update the line that indicates the last-modified date."
      (delete-and-forget-line)
      (insert (header-date-string)))

    (defun update-file-name ()
      "Update the line that indicates the file name."
      (beginning-of-line)
      ;; Verify looking at a file name for this mode.
      (when (looking-at (concat (regexp-quote (header-prefix-string)) " *\\(.*\\) *\\-\\-"))
        (goto-char (match-beginning 1))
        (delete-region (match-beginning 1) (match-end 1))
        (insert (file-name-nondirectory (buffer-file-name)) " ---")))

    (defun update-lib-requires ()
      "Update the lines that show what libraries are required by this one.
    This uses function `libreq-insert-lib-requires-as-comment' from
    library `lib-requires.el'.

    Note: If a byte-compiled file (`*.elc') for the library is available,
    it is used when determining library dependencies, in preference to the
    source library - this is the standard behavior of `load-library'.  The
    list of required libraries reflects the dependencies indicated in the
    byte-compiled file, not the source file.  If the byte-compiled file is
    out-of-date with respect to its required libraries, so will be the
    result of `update-lib-requires'."
      (when (buffer-file-name)              ; Do nothing if not a file buffer.
        (let ((lib  (file-name-sans-extension (file-name-nondirectory (buffer-file-name)))))
          (when (and (eq major-mode 'emacs-lisp-mode)
                     (fboundp 'libreq-insert-lib-requires-as-comment))
            (goto-char (match-beginning 0))
            ;; Verify looking at `libreq-file-header'"
            (when (looking-at (regexp-quote libreq-file-header))
              (delete-and-forget-line) (delete-char 1)
              (delete-and-forget-line) (delete-char 1)
              (while (not (looking-at "^;;$")) (delete-and-forget-line) (delete-char 1))
              (delete-and-forget-line) (delete-char 1)
              (condition-case err
                  ;; (let ((load-path  (cons (file-name-directory (buffer-file-name))
                  ;;                         load-path)))
                  (libreq-insert-lib-requires-as-comment lib) ; Tries to load LIB.
                ;;   )
                ;; Typically, user just now added `provide' and must load again.
                (error (insert libreq-file-header (header-prefix-string) "  "
                               (error-message-string err) ".\n;;\n"))))))))



    ;;(setq file-header-update-alist  nil)
    ;;(setq file-header-update-alist  (cdr file-header-update-alist))

    ;; Stand-alone Headers
    ;; These functions give the ability to invoke headers from the command line.
    ;;   E.g Can use with `vi' instead of emacs.
    ;; -------------------------------------------------------------------------
    (defun headerable-file-p (file)
      "Return non-nil if FILE is an existing file."
      (not (if (not (file-exists-p file))
               (message "File \"%s\" does not exist." file)
             (if (file-symlink-p file)
                 (message "\"%s\" is a symbolic link." file)
               (if (file-directory-p file)
                   (message "\"%s\" is a directory." file))))))

    (defsubst uniquify-list (list)
      "Remove duplicates in list LIST.  Comparison is with `eq'."
      (let ((rest  list))
        (while rest
          (setcdr rest (delq (car rest) (cdr rest)))
          (setq rest  (cdr rest)))
        list))

    ;;(headerable-file-p "AFS")
    ;;(headerable-file-p "dbiogen.el")
    ;;(headerable-file-p "dbiogen.elc")

    ;;; Rest commented out -- Needs Lynn Slater's
    ;;; customizations to startup.el to allow command-line-hooks.
    ;;
    ;;
    ;; (defvar header-required-mode nil
    ;;   "The mode we force files to be in, regardless of file suffix.")
    ;;
    ;; Define a touch-headers command.  This depends upon Lynn Slater's
    ;; customizations to startup.el to allow command-line-hooks.
    ;; ---------------------------------------------------------------
    ;;;(setq command-line-hooks  (cons 'touch-headers command-line-hooks))
    ;(defun touch-headers ()
    ;  (if (or (string= argi "-touch")  (string= argi "-touch-headers"))
    ;      (let ((trim-versions-without-asking  t)
    ;            ;; Next line should have a Control-G char, not a space, before `true'.
    ;            (executing-macro " true"));; suppress "Mark Set" messages
    ;        ;; Consume all following arguments until one starts with a "-"
    ;        (while (and command-line-args-left
    ;                    (not (char-equal ?- (aref (car command-line-args-left) 0))))
    ;          (if (headerable-file-p (car command-line-args-left))
    ;              (progn
    ;                (set-buffer (find-file-noselect (car command-line-args-left)))
    ;                (make-revision)
    ;                (write-file nil)
    ;                (kill-buffer (current-buffer))))
    ;          (setq command-line-args-left  (cdr command-line-args-left))))))


    ;; Define a make-headers command line option.
    ;; ------------------------------------------
    ;;;(setq command-line-hooks  (cons 'make-headers command-line-hooks))
    ;(defun make-headers ()
    ;  (if (or (string= argi "-make-headers")  (string= argi "-make"))
    ;      (let ((trim-versions-without-asking  t)
    ;            ;; Next line should have a Control-G char, not a space, before `true'.
    ;            (executing-macro " true"));; suppress "Mark Set" messages
    ;        ;; Consume all following arguments until one starts with a "-"
    ;        (while (and command-line-args-left
    ;                    (not (char-equal ?- (aref (car command-line-args-left) 0))))

    ;          (if (headerable-file-p (car command-line-args-left))
    ;              (progn
    ;                (set-buffer (find-file-noselect (car command-line-args-left)))
    ;                (if header-required-mode
    ;                    (funcall header-required-mode))
    ;                (make-header)
    ;                (write-file nil)
    ;                (message "  Mode was %s" major-mode)
    ;                (kill-buffer (current-buffer))))
    ;          (setq command-line-args-left  (cdr command-line-args-left))))))

    ;; Define a -default-mode command line option.
    ;; -------------------------------------------
    ;;;(setq command-line-hooks  (cons 'set-header-mode command-line-hooks))
    ;(defun set-header-mode ()
    ;  (if (or (string= argi "-default-mode")  (string= argi "-default"))
    ;      (let ((trim-versions-without-asking  t)
    ;            ;; Next line should have a Control-G char, not a space, before `true'.
    ;            (executing-macro " true");; suppress "Mark Set" messages
    ;            (mode (intern (car command-line-args-left))))
    ;        (if (memq mode (mapcar 'cdr auto-mode-alist))
    ;            (progn
    ;              (setq default-major-mode  mode)
    ;              (message "Default mode is %s" default-major-mode)
    ;              (setq command-line-args-left  (cdr command-line-args-left)))
    ;          (message "Mode \"%s\" is invalid.  Try one of %s" mode
    ;                   (uniquify-list (mapcar 'cdr auto-mode-alist)))
    ;          (kill-emacs 1)))))


    ;; Define a -required-mode command line option.
    ;; --------------------------------------------
    ;;;(setq command-line-hooks  (cons 'set-header-required-mode command-line-hooks))
    ;(defun set-header-required-mode ()
    ;  (if (or (string= argi "-required-mode")  (string= argi "-mode"))
    ;      (let ((trim-versions-without-asking  t)
    ;            ;; Next line should have a Control-G, not a space, char before `true'.
    ;            (executing-macro " true");; suppress "Mark Set" messages
    ;            (mode (intern (car command-line-args-left))))
    ;        (if (memq mode (mapcar 'cdr auto-mode-alist))
    ;            (progn
    ;              (setq header-required-mode  mode)
    ;              (message "Required mode is %s" header-required-mode)
    ;              (setq command-line-args-left  (cdr command-line-args-left)))
    ;          (message "Mode \"%s\" is invalid.  Try one of %s" mode
    ;                   (uniquify-list (mapcar 'cdr auto-mode-alist)))
    ;          (kill-emacs 1)))))


    ;; Things in the works or still to do.
    ;;------------------------------------
    ;; effort.el -- allows an "effort" to be resgistered in the mode line much
    ;; like the mode is.  The effort then determines some header characteristics
    ;; such as copyright.  Typical efforts would be 'gdb 'gcc, 'g++, 'emacs, etc.
    ;; This would let the copyright (and c-style) be adjusted even within
    ;; common modes.
    ;;
    ;; need ez access to values in the header
    ;; need a headerp fcn
    ;;
    ;; auto make-revision if current user is not same as last modifier
    ;;   this would give a history of who touched what.


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; header2.el ends here

  #+end_src

* Bash

** Bash Automated Test System

   [[https://github.com/sstephenson/bats][BATS]] is a [[http://testanything.org/][TAP]]-compliant testing framework for Bash. It provides a
   simple way to verify that the UNIX programs you write behave as
   expected.

   Bats is most useful when testing software written in Bash, but you
   can use it to test any UNIX program.

   [[https://github.com/dougm/bats-mode][bats-mode]] is an editing-mode and runner for BATS tests

   #+BEGIN_SRC emacs-lisp
     (use-package bats-mode
       :ensure t)
   #+END_SRC

* CSS

  Seems css-mode ignores global indentations settings, so lets specifically set that now.

  #+BEGIN_SRC emacs-lisp
    (use-package css-mode
      :init
      (setq css-indent-offset 2))
  #+END_SRC

* Caddy

  I've switched to using [[https://caddyserver.com/][caddy]] as my preferred webserver / reverse
  proxy. I store persistent caddy configuration using the [[https://caddyserver.com/docs/caddyfile-tutorial][Caddyfile
  DSL]]. This bit adds highlighting, indenting, etc for Caddyfile.

  #+begin_src emacs-lisp
    (use-package caddyfile-mode
      :ensure t)
  #+end_src

* Diff-hl

  Highlight SCM changes in the gutter

  #+begin_src emacs-lisp
    (use-package diff-hl
      :ensure t
      :init
      (global-diff-hl-mode)
      (diff-hl-flydiff-mode))
  #+end_src

* Docker

  Working with Dockerfiles? Why not add syntax highlighting and the ability to build images with =C-c C-b=?

  #+BEGIN_SRC emacs-lisp
    (use-package dockerfile-mode
      :ensure t)
  #+END_SRC

* Docker-tramp

  Use docker-tramp to allow editing of files inside running
  containers. We use docker in development mode a bunch and it's a
  pain in the ass to rebuild the container when testing out minor
  changes like tweaking a config setting or something. This allows me
  to open a tramp session in a running container see results more
  quickly than rebuilding the container every time. Caveat, unless
  those changes are preserved in a volume mount they disappear when
  the container exits so use =docker-tramp= with caution.

  To use =C-x C-f /docker:<user>@<container-id>:<path-to-file>=:

  #+begin_src emacs-lisp
    (use-package docker-tramp
      :ensure t)
  #+end_src
* Elixir

  I dabble with a bit of [[http://elixir-lang.org/][Elixir]] here and there so I include support
  for it, but I don't yet have any fancy tooling or configuration for
  it.

  #+BEGIN_SRC emacs-lisp
    (use-package elixir-mode
      :ensure t)
  #+END_SRC

** Embedded Elixir

   When working with Elixir templates, use =web-mode= for better
   syntax support.

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :init
       :mode
       (("\\.eex$" . web-mode)))
   #+END_SRC

** Tooling

   I'm trying out the =alchemist= package for additional Elixir language and tooling support.

   #+BEGIN_SRC emacs-lisp
     (use-package alchemist
       :ensure t)
   #+END_SRC

* expand-region

  Use expand region to expand selections with =C-== or contract them with =C-+=

  #+begin_src emacs-lisp
    (use-package expand-region
      :ensure t
      :bind (("C-=" . 'er/expand-region)
             ("C--" . 'er/contract-region)))
  #+end_src
* Gist

  My memory is terrible. To supplement I tend to keep notes in
  [[gist.github.com][gists]]. This makes it so that I can work with my gists from within
  the emacs editor.

  NOTE: User authentication information is stored elsewhere as
  described in the [[https://github.com/defunkt/gist.el#gistel----emacs-integration-for-gistgithubcom][gist.el]] documentation.

  #+BEGIN_SRC emacs-lisp
    (use-package gist
      :ensure t)
  #+END_SRC

* Git

** Magit

   Magit is a staple of my interaction with git. Its fast, and
   intuitive interface allow me to quickly complete interactions with
   the git Version Control System without lots of repetitive typing or
   cryptic aliases.

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t
       :commands magit-status magit-blame
       :bind ("C-x g" . magit-status))
   #+END_SRC
** Forge

   Forge allows you to work with Git forges, such as Github and
   Gitlab, from the comfort of Magit and the rest of Emacs.

   Forge fetches issues, pull-requests and other data using the
   forge’s API and stores that in a local database. Additionally it
   fetches the pull-request references using Git. Forge implements
   various features that use this data but the database and
   pull-request refs can also be used by third-party packages.

  #+begin_src emacs-lisp
    (use-package forge
      :ensure t
      :after magit)
  #+end_src
* Go

  I'm starting to dabble a bit with [[http://www.golang.org][go]]. Of course I want editor
  support.

  #+BEGIN_SRC elisp
    (use-package go-mode
      :ensure t
      :config
      (add-hook 'before-save-hook #'gofmt-before-save))
  #+END_SRC

* GraphQL

  Turns emacs into a graphql client

  #+begin_src elisp
    (use-package graphql-mode
      :ensure t)
  #+end_src

  Ensures that GraphQL queries can be executed from the buffer by using C-c C-c.

  #+begin_src elisp
    (use-package request
      :ensure t)
  #+end_src
* JavaScript

  Use the enhanced JavaScript editing mode - [[https://github.com/mooz/js2-mode][js2-mode]].

  #+BEGIN_SRC emacs-lisp
    (use-package js2-mode
      :ensure t
      :interpreter
      ("node" . js2-mode)
      :config
      (setq js2-basic-offset 2)
      (setq js2-highlight-level 3)
      (setq js2-mode-show-parse-errors t)
      (setq js2-mode-show-strict-warnings t))
  #+END_SRC

** React / JSX

   Add support for Facebook's XML-like JavaScript extensions to ECMAScript

   #+BEGIN_SRC emacs-lisp
     (use-package rjsx-mode
       :ensure t
       :interpreter
       ("node" . rjsx-mode)
       :mode
       ("\\.jsx?$'" . rjsx-mode)
       :config
       (setq js2-basic-offset 2)
       (setq js2-highlight-level 3)
       (setq js2-mode-show-parse-errors t)
       (setq js2-mode-show-strict-warnings t))

   #+END_SRC

* lsp-mode

  #+begin_src emacs-lisp
    ;; Ruby lsp-server integration requires "gem install solargraph"
    ;;   - https://emacs-lsp.github.io/lsp-mode/page/lsp-solargrap/
    ;; Install the rust rls lsp-server via rustup "rustup component add rls rust-analysis rust-src"
    ;;   - https://github.com/rust-lang/rls#setup
    (use-package lsp-mode
      :ensure t
      :hook ((rust-mode . lsp-deferred))
        :commands (lsp lsp-deferred))
  #+end_src

* Markdown

  I work with Github a lot. I work with other developers a lot. Not
  many of those developers use =org-mode= -- which is my preferred
  format for documentation and note taking. As such, I author shared
  documentation in Markdown as it seems to be more portable and
  completely unavoidable.

  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode
      :ensure t)
  #+END_SRC

* Org

  I use =org-mode= a lot. For note taking, formatting textual data
  with tables, and even writing notes to future versions of myself
  about my emacs configuration (Hi, future me! You handsome devil.)

  When using bullet lists, the below configuration make it easier to
  see nested contexts by using different line heights for each
  indentation level.

  #+BEGIN_SRC emacs-lisp
    (use-package org
      :ensure org-plus-contrib
      :init
      (package-initialize)
      :config
      (set-face-attribute 'org-level-1 nil :height 2.0)
      (set-face-attribute 'org-level-2 nil :height 1.75)
      (set-face-attribute 'org-level-3 nil :height 1.65)
      (set-face-attribute 'org-level-4 nil :height 1.55)
      (set-face-attribute 'org-level-5 nil :height 1.5)
      (setq org-todo-keywords
            '((sequence "TODO"
                        "STARTED"
                        "|"
                        "DONE")))
      (setq org-todo-keyword-faces
            '(("TODO" :foreground "green" :weight bold)
              ("STARTED" :foreground "orange" :weight bold)
              ("DONE" :foreground "red" :weight bold))))
  #+END_SRC

  This takes org-mode bullet lists one step farther. It renders
  indentation level bullet headers so they look like a single bullet
  at the correct indentation level. The '*' characters are still
  there, but hidden through the magic of colors.

  #+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      :ensure t
      :commands (org-bullets-mode)
      :init
      (add-hook 'org-mode-hook 'org-bullets-mode)
      (require 'ox-md))
  #+END_SRC

* Presentations

  I used to used a complex set of org-mode exporters, 3rd party
  javascript, etc to make presentations. The export pipeline often
  fell down when either emacs, org-mode, the org-mode exporter, or
  JavaScript library were updated - or worse, I just stopped upgrading
  things to compensate for the instability.

  Instead, org-present is a dead simple way to make a basic slide-show
  to accompany my talks and removes a bit of complexity compared to the
  exporter pipeline I used to use.

  #+BEGIN_SRC emacs-lisp
    (use-package org-present
      :ensure t
      :config
      (add-hook 'org-present-mode-hook
                   (lambda ()
                     (org-present-big)
                     (org-display-inline-images)
                     (org-present-read-only)))
         (add-hook 'org-present-mode-quit-hook
                   (lambda ()
                     (org-present-small)
                     (org-remove-inline-images)
                     (org-present-read-write))))
  #+END_SRC

  Give myself the option of hiding the mode line while doing presentations.

  #+BEGIN_SRC emacs-lisp
    (use-package hide-mode-line
      :ensure t)
  #+END_SRC

* Project navigation

** Fuzzy searching names and content

  Use [[https://github.com/ggreer/the_silver_searcher][The Silver Searcher]] to search through the contents of files.
  #+begin_src emacs-lisp
    ;; Search using "The silver searcher" (ag)
    (use-package ag
      :ensure t)
  #+end_src

** Group related filesystem items into "Projects"

  Make it easier to navigate through related groups of files --
  projects.

  #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :ensure t
        :bind-keymap
        ("C-c p" . projectile-command-map)
        :init
        (setq projectile-enable-caching t)
        (setq projectile-indexing-method 'alien)
        (setq projectile-completion-system 'helm)
        (setq projectile-switch-project-action 'helm-projectile)
        (add-hook 'dired-mode-hook 'projectile-mode)
        (add-hook 'elixir-mode-hook 'projectile-mode)
        (add-hook 'js-mode-hook 'projectile-mode)
        (add-hook 'ruby-mode-hook 'projectile-mode)
        (add-hook 'web-mode-hook 'projectile-mode)
        (projectile-global-mode))
  #+END_SRC

  Make it easier to navigate between related concepts in Rails
  projects.

  #+BEGIN_SRC emacs-lisp
  (use-package projectile-rails
    :ensure t)
  #+END_SRC

** Completion and narrowing selections

  Use helm to interact with search results from "the silver searcher"

  #+begin_src emacs-lisp
    (use-package helm-ag
      :ensure t)
  #+end_src

  Helm is an Emacs framework for incremental completions and narrowing
  selections. It provides an easy-to-use API for developers wishing to
  build their own Helm applications in Emacs, powerful search tools
  and dozens of already built-in commands providing completion to
  almost everything. It is a must-have for anyone using Emacs as a
  main work environment.

  #+begin_src emacs-lisp
    (use-package helm
      :ensure t
      :bind (("C-x C-f" . helm-find-files)
             ("C-x f" . helm-for-files)
             ("M-x" . helm-M-x))
      :init
      (progn
        (require 'helm-config)
        (setq helm-candidate-number-limit 100)
        (setq helm-ff-skip-boring-files t)
        (setq helm-M-x-fuzzy-match t)))
  #+end_src

  Use helm to fuzzy navigate through projects.

  #+begin_src emacs-lisp
    (use-package helm-projectile
      :ensure t
      :config
      (helm-projectile-on))
  #+end_src

  Interactively find and edit lines matching a search term

  #+begin_src emacs-lisp
    (use-package helm-swoop
      :ensure t
      :bind (("M-i" . 'helm-swoop)
             ("M-I" . 'helm-swoop-back-to-last-point)
             ("C-c M-i" . 'helm-multi-swoop)
             ("C-x M-i" . 'helm-multi-swoop-all))
      :init
      ;; Save buffer when helm-multi-swoop-edit complete
      (setq helm-multi-swoop-edit-save t)
      ;; If this value is t, split window inside the current window
      (setq helm-swoop-split-with-multiple-windows nil)
      ;; If this value is t, split window inside the current window
      (setq helm-swoop-split-with-multiple-windows nil)
      ;; If you prefer fuzzy matching
      (setq helm-swoop-use-fuzzy-match t)
      :config
      ;; When doing isearch, hand the word over to helm-swoop
      (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
      ;; From helm-swoop to helm-multi-swoop-all
      (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
      ;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
      (define-key helm-swoop-map (kbd "M-m") 'helm-multi-swoop-current-mode-from-helm-swoop)
      (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
      (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
      (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
      (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line))
  #+end_src

* Restclient

  I sometimes work with web-y things. It's nice to not have to either
  open a terminal appication or start up an =ansi-term= session to
  fire =curl= commands. This installs the an http client -
  [[https://github.com/pashky/restclient.el][restclient]] - that I can use straight from a buffer.

  #+BEGIN_SRC emacs-lisp
    (use-package restclient
       :mode
       ("\\.rest$" . restclient-mode)
       ("\\.restclient$" . restclient-mode)
      :ensure t)
  #+END_SRC

  Furthermore, integrate =restclient= mode in to org documents via org-babel

  #+BEGIN_SRC emacs-lisp
    (use-package ob-restclient
      :ensure t)

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((restclient . t)))
  #+END_SRC

* Regular Expressions

  #+BEGIN_SRC emacs-lisp
    (use-package re-builder
      :ensure t
      :config
      (setq reb-re-syntax 'string))
  #+END_SRC

* Ruby

** ruby-mode

   Associate =ruby-mode= with ruby-ish files -- like Gemfiles,
   Rakefiles, etc.

   Prevent emacs from writing the "Magic Encoding
   Comment" at the top of source files which use exotic coding
   schemes.

   Do not indent new lines to context depth, rather use a standard
   indentation. For example, format indentations like:

   #+BEGIN_EXAMPLE
     def foo(
      bar:,
      baz:
     )
      ...
     end
   #+END_EXAMPLE

   not like this:

   #+BEGIN_EXAMPLE
     def foo(
      bar:,
      baz:
     )
      ...
     end
   #+END_EXAMPLE

   #+BEGIN_SRC emacs-lisp
     (use-package ruby-mode
       :ensure t
       :bind (("C-c C-c" . xmp)
              ("M-<down>" . ruby-forward-sexp)
              ("M-<up>" . ruby-backward-sexp)
              ("C-c C-e" . ruby-send-region))
       :mode
       (("\\.rb$" . ruby-mode)
        ("\\.rake$" . ruby-mode)
        ("Rakefile$" . ruby-mode)
        ("\\.gemspec$" . ruby-mode)
        ("\\.ru$" . ruby-mode)
        ("Gemfile$" . ruby-mode)
        ("Guardfile$" . ruby-mode))
       :init
       (setq ruby-insert-encoding-magic-comment nil
             ruby-deep-indent-paren nil
             ruby-indent-tabs-mode nil)
       (add-hook 'ruby-mode 'superword-mode)
       (progn
         ;;; rcodetools.el -- annotation / accurate completion / browsing documentation

     ;;; Copyright (c) 2006-2008 rubikitch <rubikitch@ruby-lang.org>
     ;;;
     ;;; Use and distribution subject to the terms of the Ruby license.

         (defvar xmpfilter-command-name "ruby -S xmpfilter --dev --fork --detect-rbtest"
           "The xmpfilter command name.")
         (defvar rct-doc-command-name "ruby -S rct-doc --dev --fork --detect-rbtest"
           "The rct-doc command name.")
         (defvar rct-complete-command-name "ruby -S rct-complete --dev --fork --detect-rbtest"
           "The rct-complete command name.")
         (defvar ruby-toggle-file-command-name "ruby -S ruby-toggle-file"
           "The ruby-toggle-file command name.")
         (defvar rct-fork-command-name "ruby -S rct-fork")
         (defvar rct-option-history nil)                ;internal
         (defvar rct-option-local nil)     ;internal
         (make-variable-buffer-local 'rct-option-local)
         (defvar rct-debug nil
           "If non-nil, output debug message into *Messages*.")
         ;; (setq rct-debug t)

         (defadvice comment-dwim (around rct-hack activate)
           "If comment-dwim is successively called, add => mark."
           (if (and (eq major-mode 'ruby-mode)
                    (eq last-command 'comment-dwim)
                    ;; TODO =>check
                    )
               (insert "=>")
             ad-do-it))
         ;; To remove this advice.
         ;; (progn (ad-disable-advice 'comment-dwim 'around 'rct-hack) (ad-update 'comment-dwim))

         (defun rct-current-line ()
           "Return the vertical position of point..."
           (+ (count-lines (point-min) (point))
              (if (= (current-column) 0) 1 0)))

         (defun rct-save-position (proc)
           "Evaluate proc with saving current-line/current-column/window-start."
           (let ((line (rct-current-line))
                 (col  (current-column))
                 (wstart (window-start)))
             (funcall proc)
             (goto-char (point-min))
             (forward-line (1- line))
             (move-to-column col)
             (set-window-start (selected-window) wstart)))

         (defun rct-interactive ()
           "All the rcodetools-related commands with prefix args read rcodetools' common option. And store option into buffer-local variable."
           (list
            (let ((option (or rct-option-local "")))
              (if current-prefix-arg
                  (setq rct-option-local
                        (read-from-minibuffer "rcodetools option: " option nil nil 'rct-option-history))
                option))))

         (defun rct-shell-command (command &optional buffer)
           "Replacement for `(shell-command-on-region (point-min) (point-max) command buffer t' because of encoding problem."
           (let ((input-rb (concat (make-temp-name "xmptmp-in") ".rb"))
                 (output-rb (concat (make-temp-name "xmptmp-out") ".rb"))
                 (coding-system-for-read buffer-file-coding-system))
             (write-region (point-min) (point-max) input-rb nil 'nodisp)
             (shell-command
              (rct-debuglog (format "%s %s > %s" command input-rb output-rb))
              t " *rct-error*")
             (with-current-buffer (or buffer (current-buffer))
               (insert-file-contents output-rb nil nil nil t))
             (delete-file input-rb)
             (delete-file output-rb)))

         (defvar xmpfilter-command-function 'xmpfilter-command)
         (defun xmp (&optional option)
           "Run xmpfilter for annotation/test/spec on whole buffer.
        See also `rct-interactive'. "
           (interactive (rct-interactive))
           (rct-save-position
            (lambda ()
              (rct-shell-command (funcall xmpfilter-command-function option)))))

         (defun xmpfilter-command (&optional option)
           "The xmpfilter command line, DWIM."
           (setq option (or option ""))
           (cl-flet ((in-block (beg-re)
                               (save-excursion
                                 (goto-char (point-min))
                                 (when (re-search-forward beg-re nil t)
                                   (let ((s (point)) e)
                                     (when (re-search-forward "^end\n" nil t)
                                       (setq e (point))
                                       (goto-char s)
                                       (re-search-forward "# => *$" e t)))))))
             (cond ((in-block "^class.+< Test::Unit::TestCase$")
                    (format "%s --unittest %s" xmpfilter-command-name option))
                   ((in-block "^\\(describe\\|context\\).+do$")
                    (format "%s --spec %s" xmpfilter-command-name option))
                   (t
                    (format "%s %s" xmpfilter-command-name option)))))

        ;;;; Completion
         (defvar rct-method-completion-table nil) ;internal
         (defvar rct-complete-symbol-function 'rct-complete-symbol--normal
           "Function to use rct-complete-symbol.")
         ;; (setq rct-complete-symbol-function 'rct-complete-symbol--icicles)
         (defvar rct-use-test-script t
           "Whether rct-complete/rct-doc use test scripts.")

         (defun rct-complete-symbol (&optional option)
           "Perform ruby method and class completion on the text around point.
        This command only calls a function according to `rct-complete-symbol-function'.
        See also `rct-interactive', `rct-complete-symbol--normal', and `rct-complete-symbol--icicles'."
           (interactive (rct-interactive))
           (call-interactively rct-complete-symbol-function))

         (defun rct-complete-symbol--normal (&optional option)
           "Perform ruby method and class completion on the text around point.
        See also `rct-interactive'."
           (interactive (rct-interactive))
           (let ((end (point)) beg
                 pattern alist
                 completion)
             (setq completion (rct-try-completion)) ; set also pattern / completion
             (save-excursion
               (search-backward pattern)
               (setq beg (point)))
             (cond ((eq completion t)            ;sole completion
                    (message "%s" "Sole completion"))
                   ((null completion)            ;no completions
                    (message "Can't find completion for \"%s\"" pattern)
                    (ding))
                   ((not (string= pattern completion)) ;partial completion
                    (delete-region beg end)      ;delete word
                    (insert completion)
                    (message ""))
                   (t
                    (message "Making completion list...")
                    (with-output-to-temp-buffer "*Completions*"
                      (display-completion-list
                       (all-completions pattern alist)))
                    (message "Making completion list...%s" "done")))))

         ;; (define-key ruby-mode-map "\M-\C-i" 'rct-complete-symbol)

         (defun rct-debuglog (logmsg)
           "if `rct-debug' is non-nil, output LOGMSG into *Messages*. Returns LOGMSG."
           (if rct-debug
               (message "%s" logmsg))
           logmsg)

         (defun rct-exec-and-eval (command opt)
           "Execute rct-complete/rct-doc and evaluate the output."
           (let ((eval-buffer  (get-buffer-create " *rct-eval*")))
             ;; copy to temporary buffer to do completion at non-EOL.
             (rct-shell-command
              (format "%s %s %s --line=%d --column=%d %s"
                      command opt (or rct-option-local "")
                      (rct-current-line)
                      ;; specify column in BYTE
                      (string-bytes
                       (encode-coding-string
                        (buffer-substring (point-at-bol) (point))
                        buffer-file-coding-system))
                      (if rct-use-test-script (rct-test-script-option-string) ""))
              eval-buffer)
             (message "")
             (eval (with-current-buffer eval-buffer
                     (goto-char 1)
                     (unwind-protect
                         (read (current-buffer))
                       (unless rct-debug (kill-buffer eval-buffer)))))))

         (defun rct-test-script-option-string ()
           (if (null buffer-file-name)
               ""
             (let ((test-buf (rct-find-test-script-buffer))
                   (bfn buffer-file-name)
                   bfn2 t-opt test-filename)
               (if (and test-buf
                        (setq bfn2 (buffer-local-value 'buffer-file-name test-buf))
                        (file-exists-p bfn2))
                   ;; pass test script's filename and lineno
                   (with-current-buffer test-buf
                     (setq t-opt (format "%s@%s" buffer-file-name (rct-current-line)))
                     (format "-t %s --filename=%s" t-opt bfn))
                 ""))))

         (require 'cl)

         (defun rct-find-test-script-buffer (&optional buffer-list)
           "Find the latest used Ruby test script buffer."
           (setq buffer-list (or buffer-list (buffer-list)))
           (dolist (buf buffer-list)
             (with-current-buffer buf
               (if (and buffer-file-name (string-match "test.*\.rb$" buffer-file-name))
                   (return buf)))))

         ;; (defun rct-find-test-method (buffer)
         ;;   "Find test method on point on BUFFER."
         ;;   (with-current-buffer buffer
         ;;     (save-excursion
         ;;       (forward-line 1)
         ;;       (if (re-search-backward "^ *def *\\(test_[A-Za-z0-9?!_]+\\)" nil t)
         ;;           (match-string 1)))))

         (defun rct-try-completion ()
           "Evaluate the output of rct-complete."
           (rct-exec-and-eval rct-complete-command-name "--completion-emacs"))

        ;;;; TAGS or Ri
         (autoload 'ri "ri-ruby" nil t)
         (defvar rct-find-tag-if-available t
           "If non-nil and the method location is in TAGS, go to the location instead of show documentation.")
         (defun rct-ri (&optional option)
           "Browse Ri document at the point.
        If `rct-find-tag-if-available' is non-nil, search the definition using TAGS.

        See also `rct-interactive'. "
           (interactive (rct-interactive))
           (rct-exec-and-eval
            rct-doc-command-name
            (concat "--ri-emacs --use-method-analyzer "
                    (if (buffer-file-name)
                        (concat "--filename=" (buffer-file-name))
                      ""))))

         (defun rct-find-tag-or-ri (fullname)
           (if (not rct-find-tag-if-available)
               (ri fullname)
             (condition-case err
                 (let ()
                   (visit-tags-table-buffer)
                   (find-tag-in-order (concat "::" fullname) 'search-forward '(tag-exact-match-p) nil  "containing" t))
               (error
                (ri fullname)))))

        ;;;;
         (defun ruby-toggle-buffer ()
           "Open a related file to the current buffer. test<=>impl."
           (interactive)
           (find-file (shell-command-to-string
                       (format "%s %s" ruby-toggle-file-command-name buffer-file-name))))

        ;;;; rct-fork support
         (defun rct-fork (options)
           "Run rct-fork.
        Rct-fork makes xmpfilter and completion MUCH FASTER because it pre-loads heavy libraries.
        When rct-fork is running, the mode-line indicates it to avoid unnecessary run.
        To kill rct-fork process, use \\[rct-fork-kill].
        "
           (interactive (list
                         (read-string "rct-fork options (-e CODE -I LIBDIR -r LIB): "
                                      (rct-fork-default-options))))
           (rct-fork-kill)
           (rct-fork-minor-mode 1)
           (start-process-shell-command
            "rct-fork" "*rct-fork*" rct-fork-command-name options))

         (defun rct-fork-default-options ()
           "Default options for rct-fork by collecting requires."
           (mapconcat
            (lambda (lib) (format "-r %s" lib))
            (save-excursion
              (goto-char (point-min))
              (loop while (re-search-forward "\\<require\\> ['\"]\\([^'\"]+\\)['\"]" nil t)
                    collect (match-string-no-properties 1)))
            " "))

         (defun rct-fork-kill ()
           "Kill rct-fork process invoked by \\[rct-fork]."
           (interactive)
           (when rct-fork-minor-mode
             (rct-fork-minor-mode -1)
             (interrupt-process "rct-fork")))
         (define-minor-mode rct-fork-minor-mode
           "This minor mode is turned on when rct-fork is run.
        It is nothing but an indicator."
           :lighter " <rct-fork>" :global t)

        ;;;; unit tests
         (when (and (fboundp 'expectations))
           (require 'ruby-mode)
           (require 'el-mock nil t)
           (expectations
            (desc "comment-dwim advice")
            (expect "# =>"
                    (with-temp-buffer
                      (ruby-mode)
                      (setq last-command nil)
                      (call-interactively 'comment-dwim)
                      (setq last-command 'comment-dwim)
                      (call-interactively 'comment-dwim)
                      (buffer-string)))
            (expect (regexp "^1 +# =>")
                    (with-temp-buffer
                      (ruby-mode)
                      (insert "1")
                      (setq last-command nil)
                      (call-interactively 'comment-dwim)
                      (setq last-command 'comment-dwim)
                      (call-interactively 'comment-dwim)
                      (buffer-string)))

            (desc "rct-current-line")
            (expect 1
                    (with-temp-buffer
                      (rct-current-line)))
            (expect 1
                    (with-temp-buffer
                      (insert "1")
                      (rct-current-line)))
            (expect 2
                    (with-temp-buffer
                      (insert "1\n")
                      (rct-current-line)))
            (expect 2
                    (with-temp-buffer
                      (insert "1\n2")
                      (rct-current-line)))

            (desc "rct-save-position")
            (expect (mock (set-window-start * 7) => nil)
                    (stub window-start => 7)
                    (with-temp-buffer
                      (insert "abcdef\nghi")
                      (rct-save-position #'ignore)))
            (expect 2
                    (with-temp-buffer
                      (stub window-start => 1)
                      (stub set-window-start => nil)
                      (insert "abcdef\nghi")
                      (rct-save-position #'ignore)
                      (rct-current-line)))
            (expect 3
                    (with-temp-buffer
                      (stub window-start => 1)
                      (stub set-window-start => nil)
                      (insert "abcdef\nghi")
                      (rct-save-position #'ignore)
                      (current-column)))

            (desc "rct-interactive")
            (expect '("read")
                    (let ((current-prefix-arg t))
                      (stub read-from-minibuffer => "read")
                      (rct-interactive)))
            (expect '("-S ruby19")
                    (let ((current-prefix-arg nil)
                          (rct-option-local "-S ruby19"))
                      (stub read-from-minibuffer => "read")
                      (rct-interactive)))
            (expect '("")
                    (let ((current-prefix-arg nil)
                          (rct-option-local))
                      (stub read-from-minibuffer => "read")
                      (rct-interactive)))

            (desc "rct-shell-command")
            (expect "1+1 # => 2\n"
                    (with-temp-buffer
                      (insert "1+1 # =>\n")
                      (rct-shell-command "xmpfilter")
                      (buffer-string)))

            (desc "xmp")

            (desc "xmpfilter-command")
            (expect "xmpfilter --rails"
                    (let ((xmpfilter-command-name "xmpfilter"))
                      (with-temp-buffer
                        (insert "class TestFoo < Test::Unit::TestCase\n")
                        (xmpfilter-command "--rails"))))
            (expect "xmpfilter "
                    (let ((xmpfilter-command-name "xmpfilter"))
                      (with-temp-buffer
                        (insert "context 'foo' do\n")
                        (xmpfilter-command))))
            (expect "xmpfilter "
                    (let ((xmpfilter-command-name "xmpfilter"))
                      (with-temp-buffer
                        (insert "describe Array do\n")
                        (xmpfilter-command))))
            (expect "xmpfilter --unittest --rails"
                    (let ((xmpfilter-command-name "xmpfilter"))
                      (with-temp-buffer
                        (insert "class TestFoo < Test::Unit::TestCase\n"
                                "  def test_0\n"
                                "    1 + 1 # =>\n"
                                "  end\n"
                                "end\n")
                        (xmpfilter-command "--rails"))))
            (expect "xmpfilter --spec "
                    (let ((xmpfilter-command-name "xmpfilter"))
                      (with-temp-buffer
                        (insert "context 'foo' do\n"
                                "  specify \"foo\" do\n"
                                "    1 + 1 # =>\n"
                                "  end\n"
                                "end\n")
                        (xmpfilter-command))))
            (expect "xmpfilter --spec "
                    (let ((xmpfilter-command-name "xmpfilter"))
                      (with-temp-buffer
                        (insert "describe Array do\n"
                                "  it \"foo\" do\n"
                                "    [1] + [1] # =>\n"
                                "  end\n"
                                "end\n")
                        (xmpfilter-command))))
            (expect "xmpfilter "
                    (let ((xmpfilter-command-name "xmpfilter"))
                      (with-temp-buffer
                        (insert "1 + 2\n")
                        (xmpfilter-command))))

            (desc "rct-fork")
            (expect t
                    (stub start-process-shell-command => t)
                    (stub interrupt-process => t)
                    (rct-fork "-r activesupport")
                    rct-fork-minor-mode)
            (expect nil
                    (stub start-process-shell-command => t)
                    (stub interrupt-process => t)
                    (rct-fork "-r activesupport")
                    (rct-fork-kill)
                    rct-fork-minor-mode)
            ))

         (provide 'rcodetools)))
   #+END_SRC

** rbenv

   I use [[http://rbenv.org/][rbenv]] to manage my ruby versions. Here I make emacs rbenv aware.

   #+BEGIN_SRC emacs-lisp
     (use-package rbenv
       :ensure t
       :init
       (setq rbenv-installation-dir (file-chase-links "/usr/local/opt/rbenv")))
  #+END_SRC

** ruby-end

   Similar to electric-paren, ruby-end takes care of automatically
   inserting end to close blocks, methods, and conditionals.

   #+BEGIN_SRC emacs-lisp
     (use-package ruby-end
       :ensure t)
   #+END_SRC

** rspec

   I, sometimes, like to run targeted groups of specs from within
   emacs. Here I make emacs aware of rspec and how to run groups of
   specs. This also enables debugging in emacs with tools like [[https://github.com/deivid-rodriguez/byebug][byebug]]
   and [[https://github.com/pry/pry][pry]].

   #+BEGIN_SRC emacs-lisp
     (use-package rspec-mode
       :ensure t
       :init
       (add-hook 'after-init-hook 'inf-ruby-switch-setup)
       :config
       (add-hook 'rspec-compilation-mode-hook
                 (lambda ()
                   (company-mode -1)
                   (make-local-variable 'compilation-scroll-output)
                   (setq compilation-scroll-output 'first-error))))
   #+END_SRC

** inf-ruby

   I want to be able to use the ruby REPL inside of emacs. This
   enables the "inferior ruby" mode

   #+BEGIN_SRC emacs-lisp
     (use-package inf-ruby
       :ensure t
       :init
       (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)
       :config
       (add-hook 'inf-ruby-mode-hook
                 (lambda ()
                   (company-mode -1))))
   #+END_SRC

** erb

   Use =web-mode= to edit HTML ERB templates

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :mode
       ("\\html.erb$" . web-mode)
       :init
       (setq web-mode-markup-indent-offset 2))
   #+END_SRC

** YAML

   I mostly run into YAML when dealing with ruby configuration. This
   makes it easier to work with and format YAML.

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :mode(
             ("\\.yml$" . yaml-mode)
             ("\\.yaml$" . yaml-mode)
             ("\\.yml.erb$" . yaml-mode)
             ("\\.yaml.erb$" . yaml-mode))
       :ensure t)
   #+END_SRC

* Rust

  [[https://twitter.com/sgrif][Sean Griffin]] makes noises about [[https://www.rust-lang.org/en-US/][rust]] on the [[http://bikeshed.fm][Bikeshed]] podcast. He
  seems an intelligent and handsome man. Having spent some time with
  Go I'm going to invest some cycles trying to get to know this rust
  thing the kids are getting on about.

  #+BEGIN_SRC emacs-lisp
    (use-package flycheck-rust
      :ensure t
      :init
      (with-eval-after-load 'rust-mode
        (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)))

    (use-package rust-mode
      :ensure t
      :init
      (add-hook 'before-save-hook
                (lambda () (when (eq 'rust-mode major-mode)
                             (lsp-format-buffer)))))
  #+END_SRC

  Add minor-mode for the rust package manager [[https://doc.rust-lang.org/stable/cargo/][cargo]]

  #+BEGIN_SRC emacs-lisp
    (use-package cargo
      :ensure t)
  #+END_SRC

* Shell

  I write quite a bit of bash. [[https://github.com/koalaman/shellcheck][Shellcheck]] says it can help me learn to
  be better at it. This integrates shellcheck into the flycheck system
  for shell scripts - in editor shell script linting.

  #+begin_src emacs-lisp
    ;;; Define a flycheck checker for shellcheck
    ;;; From: https://github.com/flycheck/flycheck/blob/0f144f13a07e202169acb63880d989cb41787759/doc/developer/developing.rst#writing-more-complex-checkers
    (flycheck-define-checker sh-shellcheck
      "A shell script syntax and style checker using Shellcheck.

        See URL `https://github.com/koalaman/shellcheck/'."
      :command ("shellcheck"
                "--format" "checkstyle"
                "--shell" (eval (symbol-name sh-shell))
                (option-flag "--external-sources"
                             flycheck-shellcheck-follow-sources)
                (option "--exclude" flycheck-shellcheck-excluded-warnings list
                        flycheck-option-comma-separated-list)
                "-")
      :standard-input t
      :modes sh-mode
      :error-parser flycheck-parse-checkstyle
      :error-filter (lambda (errors)
                      (flycheck-remove-error-file-names "-" errors))
      :predicate (lambda () (memq sh-shell '(bash ksh88 sh)))
      :verify
      (lambda (_)
        (let ((supported (memq sh-shell '(bash ksh88 sh))))
          (list (flycheck-verification-result-new
                 :label (format "Shell %s supported" sh-shell)
                 :message (if supported "yes" "no")
                 :face (if supports-shell 'success '(bold warning))))))
      :error-explainer
      (lambda (err)
        (let ((error-code (flycheck-error-id err))
              (url "https://github.com/koalaman/shellcheck/wiki/%S"))
          (and error-code `(url . ,(format url error-code))))))
  #+end_src

* Static site/blog generation

  I generate my [[https://aaronkuehler.com][personal website]] from a set of org-mode source
  files. I use [[I%20am%20pragmatic%20in%20my%20practice][org-page]] handle the heavy lifting. Here lies the
  necessary configuration to automate the generation and publishing
  process.

  #+BEGIN_SRC emacs-lisp
    (use-package org-page
      ;;:disabled
      :ensure t
      :config
      (setq op/repository-directory "~/Developer/indiebrain.github.io")
      (setq op/site-domain "https://aaronkuehler.com")
      (setq op/personal-github-link "https://github.com/indiebrain")
      (setq op/site-main-title "Aaron Kuehler")
      (setq op/site-sub-title "80% Scientist, 20% Artist. Theorist and Practitioner.")
      (setq op/theme-root-directory "~/Developer/indiebrain.github.io/themes")
      (setq op/theme 'indiebrain)
      (setq op/category-config-alist
            (cons '("resume"
                    :show-meta nil
                    :show-comment nil
                    :uri-generator op/generate-uri
                    :uri-template "/resume/"
                    :sort-by :date
                    :category-index nil)
                  op/category-config-alist))
      (setq op/category-ignore-list
            (cons "resume" op/category-ignore-list))
      (setq op/category-ignore-list
            (cons "drafts" op/category-ignore-list)))
  #+End_SRC

  I am human, sometimes I'm not as effective at expressing my ideas clearly in text. I use [[https://github.com/bnbeckwith/writegood-mode][writegood-mode]] to help me.

  #+BEGIN_SRC emacs-lisp
    (use-package writegood-mode
      :ensure t)
  #+END_SRC

* SASS

  Prevent =sass-mode= from compiling sass files on save

  #+BEGIN_SRC emacs-lisp
    (use-package sass-mode
      :ensure t
      :init
      (setq-default scss-compile-at-save nil))
  #+END_SRC

* web-mode

  When working with HTML templates, let's use an indentation style
  that's consistent with other coding indentation rules.

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :init
       (setq web-mode-markup-indent-offset 2)
       (setq web-mode-css-indent-offset 2)
       (setq web-mode-code-indent-offset 2)
       (setq web-mode-indent-style 2)
       (setq web-mode-block-padding 2))
   #+END_SRC
