* Emacs Configuration

This emacs configuration is inspired by Harry R. Schwartz's "Getting
started with Org mode" [[https://www.youtube.com/watch?v%3DSzA2YODtgK4][talk]].

* Package Management

** Repositories

  Setup the package repositories. I use the canonical GNU repository, as
  well as a handful of community supported repositories.

  #+BEGIN_SRC emacs-lisp
    (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
    (add-to-list 'package-archives '("marmalade" . "https://marmalade-repo.org/packages/"))
    (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  #+END_SRC

** =use-package=

  Make sure use-package is installed. use-package is used to install,
  and load/configure packages lazily. This should be the only package
  that needs to be explicitly installed via the =package.el= manager.

  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package)
      (require 'use-package))
  #+END_SRC

* Path Management

  The path must explicitly be loaded into Emacs on Mac OS X. NOTE: this
  happens automatically on Linux.

  #+BEGIN_SRC emacs-lisp
    (use-package exec-path-from-shell
      :if (memq window-system '(mac ns x))
      :ensure t
      :config
      (exec-path-from-shell-initialize)
      (setq exec-path (cons "/opt/local/bin" exec-path))
      (setenv "PATH" (concat "/opt/local/bin:" (getenv "PATH"))))
  #+END_SRC

* UI Preferences

** Set font size

   I like a slightly larger than usual font. This little helper allows
   me to describe and set the font size in "points"

   #+BEGIN_SRC emacs-lisp
     (defun set-font-size (points)
       (interactive "n Font Size in Points: ")
       (cl-flet ((font-height (points) (* 10 points)))
         (set-face-attribute 'default nil :height (font-height points))))

     (set-font-size 14)
   #+END_SRC

** Hide emacs startup message

   I don't find the emacs welcome message useful, so prevent it on startup.

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
   #+END_SRC

** Disable default scratch buffer message

   I don’t find the explanatory message of the scratch buffer useful, so don’t show it.

   #+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message "")
   #+END_SRC

** Show the point's line and column numbers

   I don't use fringe line number, but I still like knowing the
   coordinates of my point. This enables the mode-line point coordinates.

   #+BEGIN_SRC emacs-lisp
     (line-number-mode t)
     (column-number-mode t)
   #+END_SRC

** Initialize the color-theme

   I prefer the [[https://github.com/morhetz/gruvbox][Gruvbox]] color theme

   #+BEGIN_SRC emacs-lisp  (use-package gruvbox-theme
     (use-package gruvbox-theme
       :ensure t
       :config
       (load-theme 'gruvbox-dark-medium t))
   #+END_SRC

** Disable menu, toolbar, and scrollbar UI elements

   I don't use the menu or scrollbar UI elements so I disable them to
   get back some screen real estate

   #+BEGIN_SRC emacs-lisp
     (use-package menu-bar
       :commands menu-bar-mode
       :init (menu-bar-mode -1))

     (use-package tool-bar
       :commands tool-bar-mode
       :init (tool-bar-mode -1))

     (use-package scroll-bar
       :commands scroll-bar-mode
       :init
       (scroll-bar-mode -1)
       (when (fboundp 'horizontal-scroll-bar-mode)
   (horizontal-scroll-bar-mode -1)))
   #+END_SRC

   Always highlight the current line of the point.

   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode)
   #+END_SRC

** Line Wrapping

   Use soft line wrapping for text modes

   #+BEGIN_SRC emacs-lisp
     (add-hook 'markdown-mode-hook 'visual-line-mode)
     (add-hook 'org-mode-hook 'visual-line-mode)
   #+END_SRC

** Region Highlighting

   Make the region selection a bit easier to see.

   #+begin_src emacs-lisp
     (set-face-attribute 'region nil :background "#666")
   #+end_src

* Buffer preferences

** Prefer two space character indentation

   In my experience, whitespace is more portable than <tab>
   characters. As such, I use two white-space characters for
   indentation.

   #+BEGIN_SRC emacs-lisp
     (setq-default tab-width 2)
     (setq-default indent-tabs-mode nil)
   #+END_SRC

** Ensure that files end with a newline character

   This tends to be part of the code-style of many organizations for
   which I do work and it doesn't hurt to make sure that the last
   character in any file is a \n character so I make it the default.

   #+BEGIN_SRC emacs-lisp
     (setq require-final-newline t)
   #+END_SRC

** Remove trailing whitespace on save

   Extra end-of-line whitespace bugs me, but I'm also prone to
   introducing it so automatically trim trailing whitespace when a
   buffer is saved.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook 'whitespace-cleanup)
   #+END_SRC

** Show and match bracket pairs

   Highligh matching brackets and when I open a bracket, autmaically
   close it for me:

   For example: [], (), {}, et cetera.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode t)
     (electric-pair-mode t)
   #+END_SRC

** Allow deletion of highlighted regions

   I like to be able to select a region and delete it.

   #+BEGIN_SRC emacs-lisp
     (delete-selection-mode t)
   #+END_SRC


** Undo

   I've oft found the default Emacs undo functionality gets a bit
   confusing when undo/redo comes into play. [[https://github.com/terryfinn][Terry]] agrees and uses undo-tree to get around this

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :ensure t
       :init
       (global-undo-tree-mode))
   #+END_SRC

* Window preferences

** Arrangement

   I edit multiple buffers across many open windows. Organization of
   these windows becomes a chore and I always forget the window
   resizing chords. [[https://github.com/terryfinn][Terry]] said "Give [[https://truongtx.me/2014/11/15/auto-resize-windows-by-golden-ratio-in-emacs][this]] a shot!" So I'm giving this
   a shot.

   #+BEGIN_SRC emacs-lisp
     (use-package golden-ratio
       :ensure t
       :init
       (setq split-width-threshold nil)
       :config
       (golden-ratio-mode 1))
   #+END_SRC

* Authentication

  Some of my emacs packages, like =magit=, require authentication
  credentials to interact with 3rd party services I use, like
  =Github=, =Gitlab=, etc. I store credentials encrypted by my GPG
  keys in =~/.authinfo.gpg=. Here I tell emacs where to find such credentials.

  To create the =~/.authinfo.gpg=:

  1. Create a plaintext =~/.authinfo= file
  2. Place authentication credentials - an example for =magit=
     #+begin_src text
       machine api.github.com login <github-username>^forge password <api-token>
     #+end_src
  3. Use emacs' "EasyPG" to encrypt the file with my gpg key and save it as =~/.authinfo.gpg= - =M-x epa-encrypt-file=
  4. Remove the plaintext =~/.authinfo=

  #+begin_src emacs-lisp
    (setq auth-sources '("~/.authinfo.gpg"))
  #+end_src

* Auto-save and Backups Behavior

** Centralize auto-save and backup locations

  I like to keep all of Emacs' auto-generated saves and backups tidily
  in a central place rather than littering the filesystem. Here I tell
  emacs to redirect the generated files to a known directory when it
  auto-saves.

  #+BEGIN_SRC emacs-lisp
    (make-directory "~/.emacs.d/autosaves/" t)
    (make-directory "~/.emacs.d/backups/" t)

    (setq auto-save-file-name-transforms
    (quote ((".*" "~/.emacs.d/autosaves/\\1" t))))
    (setq backup-directory-alist
    (quote ((".*" . "~/.emacs.d/backups/"))))
  #+END_SRC

** Centralize =tramp= backups

   For the same reasons as auto-saves and backups, I keep backups from
   Tramp mode in the same centralized location.

   #+BEGIN_SRC emacs-lisp
     (setq tramp-backup-directory-alist backup-directory-alist)
   #+END_SRC

** Enable backups for files under version control

   Just because the file is under version control does not mean I
   don’t care about backups. Lets make sure they are still getting
   backed up.

   #+BEGIN_SRC emacs-lisp
     (setq vc-make-backup-files t)
   #+END_SRC

** Save on lose focus

   When I leave emacs or change a buffer, auto-save all open buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package super-save
       :ensure t
       :init
       (super-save-mode t)
       (setq super-save-auto-save-when-idle t))
   #+END_SRC

* Better scrolling

** Make scrolling smoother and scroll one line at a time

   The default emacs scrolling behavior can be difficult to use; the text
   jumps too much too fast. This should make scrolling a little bit more
   smooth when in GUI emacs.

   #+BEGIN_SRC emacs-lisp
     (when window-system
       (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
       (setq mouse-wheel-progressive-speed nil)
       (setq mouse-wheel-follow-mouse 't)
       (setq scroll-step 1))
   #+END_SRC

* Syntax checking

  I generally find checking syntax and structure useful, and flycheck
  does this well, and has many plugins that I can enable in other
  modes, so lets make sure it is installed and enabled here.

  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :init
      (add-hook 'after-init-hook #'global-flycheck-mode)
      :config
      (setq-default flycheck-disabled-checkers (append flycheck-disabled-checkers '(javascript-jshint)))
      (flycheck-add-mode 'javascript-eslint 'js-mode)
      (flycheck-add-mode 'javascript-eslint 'js2-mode)
      (flycheck-add-mode 'javascript-eslint 'rjsx-mode)
      (setq flycheck-javascript-eslint-executable "node_modules/.bin/eslint")
      (setq flycheck-ruby-rubocop-executable "bin/rubocop"))
  #+END_SRC

* Spell Checking

  I am prone to typos. Enable flyspell in textual contexts to help
  catch the times where I don't quite English so well.

  #+BEGIN_SRC emacs-lisp
    (use-package flyspell
      :diminish flyspell-mode
      :commands (flyspell-prog-mode flyspell-mode)
      :init
      (if (string-equal system-type "darwin") (setq ispell-program-name "/usr/local/bin/aspell"))
      (add-hook 'ruby-mode-hook 'flyspell-prog-mode)
      (add-hook 'markdown-mode-hook 'flyspell-mode)
      (add-hook 'org-mode-hook 'flyspell-mode)
      (add-hook 'text-mode-hook 'flyspell-mode))


  #+END_SRC

* Auto Complete

  I find auto completion allows the speed of my hands to more closely
  match the speed of my brain and avoids typos. I used to use
  =auto-complete=, but a friend has convinced me to try =company-mode=
  so let's give it a shot.

  #+BEGIN_SRC emacs-lisp
    (use-package company
      :ensure t
      :diminish company-mode
      :bind ("C-:" . company-complete)
      :init
      (setq company-dabbrev-ignore-case t
      company-show-numbers t)
      (add-hook 'after-init-hook 'global-company-mode)
      :config
      (add-to-list 'company-backends 'company-math-symbols-unicode))
  #+END_SRC

* Auto Insert

  Automatically insert bits into buffers

  #+begin_src emacs-lisp
    (use-package autoinsert
      :hook ((prog-mode yaml-mode) . auto-insert-mode)
      :config
      (setq auto-insert-query nil)
      (setq auto-insert-alist
            (-cons*
             '("\\.rb\\'" nil "# frozen_string_literal: true\n")
             auto-insert-alist)))
  #+end_src

  #+begin_src emacs-lisp
    (use-package header2
      :ensure t
      :config
      (add-hook 'ruby-mode 'auto-make-header))
  #+end_src

* Bash

** Bash Automated Test System

   [[https://github.com/sstephenson/bats][BATS]] is a [[http://testanything.org/][TAP]]-compliant testing framework for Bash. It provides a
   simple way to verify that the UNIX programs you write behave as
   expected.

   Bats is most useful when testing software written in Bash, but you
   can use it to test any UNIX program.

   [[https://github.com/dougm/bats-mode][bats-mode]] is an editing-mode and runner for BATS tests

   #+BEGIN_SRC emacs-lisp
     (use-package bats-mode
       :ensure t)
   #+END_SRC

* CSS

  Seems css-mode ignores global indentations settings, so lets specifically set that now.

  #+BEGIN_SRC emacs-lisp
    (use-package css-mode
      :ensure t
      :init
      (setq css-indent-offset 2))
  #+END_SRC

* Docker

  Working with Dockerfiles? Why not add syntax highlighting and the ability to build images with =C-c C-b=?

  #+BEGIN_SRC emacs-lisp
    (use-package dockerfile-mode
      :ensure t)
  #+END_SRC

* Diff-hl

  Highlight SCM changes in the gutter

  #+begin_src emacs-lisp
    (use-package diff-hl
      :ensure t
      :init
      (global-diff-hl-mode)
      (diff-hl-flydiff-mode))
  #+end_src

* docker-tramp

  Use docker-tramp to allow editing of files inside running
  containers. We use docker in development mode a bunch and it's a
  pain in the ass to rebuild the container when testing out minor
  changes like tweaking a config setting or something. This allows me
  to open a tramp session in a running container see results more
  quickly than rebuilding the container every time. Caveat, unless
  those changes are preserved in a volume mount they disappear when
  the container exits so use =docker-tramp= with caution.

  To use =C-x C-f /docker:<user>@<container-id>:<path-to-file>=:

  #+begin_src emacs-lisp
    (use-package docker-tramp
      :ensure t)
  #+end_src
* Elixir

  I dabble with a bit of [[http://elixir-lang.org/][Elixir]] here and there so I include support
  for it, but I don't yet have any fancy tooling or configuration for
  it.

  #+BEGIN_SRC emacs-lisp
    (use-package elixir-mode
      :ensure t)
  #+END_SRC

** Embedded Elixir

   When working with Elixir templates, use =web-mode= for better
   syntax support.

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :init
       :mode
       (("\\.eex$" . web-mode)))
   #+END_SRC

** Tooling

   I'm trying out the =alchemist= package for additional Elixir language and tooling support.

   #+BEGIN_SRC emacs-lisp
     (use-package alchemist
       :ensure t)
   #+END_SRC

* Gist

  My memory is terrible. To supplement I tend to keep notes in
  [[gist.github.com][gists]]. This makes it so that I can work with my gists from within
  the emacs editor.

  NOTE: User authentication information is stored elsewhere as
  described in the [[https://github.com/defunkt/gist.el#gistel----emacs-integration-for-gistgithubcom][gist.el]] documentation.

  #+BEGIN_SRC emacs-lisp
    (use-package gist
      :ensure t)
  #+END_SRC

* Git

** Magit

   Magit is a staple of my interaction with git. Its fast, and
   intuitive interface allow me to quickly complete interactions with
   the git Version Control System without lots of repetitive typing or
   cryptic aliases.

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t
       :commands magit-status magit-blame
       :bind ("C-x g" . magit-status))
   #+END_SRC
** Forge

   Forge allows you to work with Git forges, such as Github and
   Gitlab, from the comfort of Magit and the rest of Emacs.

   Forge fetches issues, pull-requests and other data using the
   forge’s API and stores that in a local database. Additionally it
   fetches the pull-request references using Git. Forge implements
   various features that use this data but the database and
   pull-request refs can also be used by third-party packages.

  #+begin_src emacs-lisp
    (use-package forge
      :ensure t
      :after magit)
  #+end_src
* Go

  I'm starting to dabble a bit with [[http://www.golang.org][go]]. Of course I want editor
  support.

  #+BEGIN_SRC elisp
    (use-package go-mode
      :ensure t
      :config
      (add-hook 'before-save-hook #'gofmt-before-save))
  #+END_SRC

* GraphQL

  Turns emacs into a graphql client

  #+begin_src elisp
    (use-package graphql-mode
      :ensure t)
  #+end_src

  Ensures that GraphQL queries can be executed from the buffer by using C-c C-c.

  #+begin_src elisp
    (use-package request
      :ensure t)
  #+end_src
* JavaScript

  Use the enhanced JavaScript editing mode - [[https://github.com/mooz/js2-mode][js2-mode]].

  #+BEGIN_SRC emacs-lisp
    (use-package js2-mode
      :ensure t
      :interpreter
      ("node" . js2-mode)
      :config
      (setq js2-basic-offset 2)
      (setq js2-highlight-level 3)
      (setq js2-mode-show-parse-errors t)
      (setq js2-mode-show-strict-warnings t))
  #+END_SRC

** React / JSX

   Add support for Facebook's XML-like JavaScript extensions to ECMAScript

   #+BEGIN_SRC emacs-lisp
     (use-package rjsx-mode
       :ensure t
       :interpreter
       ("node" . rjsx-mode)
       :mode
       ("\\.jsx?\\'" . rjsx-mode)
       :config
       (setq js2-basic-offset 2)
       (setq js2-highlight-level 3)
       (setq js2-mode-show-parse-errors t)
       (setq js2-mode-show-strict-warnings t))

   #+END_SRC

* lsp-mode

  #+begin_src emacs-lisp
    ;; Ruby lsp-server integration requires "gem install solargraph"
    ;;   - https://emacs-lsp.github.io/lsp-mode/page/lsp-solargrap/
    ;; Install the rust rls lsp-server via rustup "rustup component add rls rust-analysis rust-src"
    ;;   - https://github.com/rust-lang/rls#setup
    (use-package lsp-mode
      :ensure t
      :hook (
             (ruby-mode . lsp-deferred)
             (rust-mode . lsp-deferred))
        :commands (lsp lsp-deferred))
  #+end_src

* Markdown

  I work with Github a lot. I work with other developers a lot. Not
  many of those developers use =org-mode= -- which is my preferred
  format for documentation and note taking. As such, I author shared
  documentation in Markdown as it seems to be more portable and
  completely unavoidable.

  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode
      :ensure t)
  #+END_SRC

* Org

  I use =org-mode= a lot. For note taking, formatting textual data
  with tables, and even writing notes to future versions of myself
  about my emacs configuration (Hi, future me! You handsome devil.)

  When using bullet lists, the below configuration make it easier to
  see nested contexts by using different line heights for each
  indentation level.

  #+BEGIN_SRC emacs-lisp
    (use-package org
      :ensure org-plus-contrib
      :init
      (package-initialize)
      :config
      (set-face-attribute 'org-level-1 nil :height 2.0)
      (set-face-attribute 'org-level-2 nil :height 1.75)
      (set-face-attribute 'org-level-3 nil :height 1.65)
      (set-face-attribute 'org-level-4 nil :height 1.55)
      (set-face-attribute 'org-level-5 nil :height 1.5)
      (setq org-todo-keywords
            '((sequence "TODO"
                        "STARTED"
                        "|"
                        "DONE")))
      (setq org-todo-keyword-faces
            '(("TODO" :foreground "green" :weight bold)
              ("STARTED" :foreground "orange" :weight bold)
              ("DONE" :foreground "red" :weight bold))))
  #+END_SRC

  This takes org-mode bullet lists one step farther. It renders
  indentation level bullet headers so they look like a single bullet
  at the correct indentation level. The '*' characters are still
  there, but hidden through the magic of colors.

  #+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      :ensure t
      :commands (org-bullets-mode)
      :init
      (add-hook 'org-mode-hook 'org-bullets-mode)
      (require 'ox-md))
  #+END_SRC

* Presentations

  I used to used a complex set of org-mode exporters, 3rd party
  javascript, etc to make presentations. The export pipeline often
  fell down when either emacs, org-mode, the org-mode exporter, or
  JavaScript library were updated - or worse, I just stopped upgrading
  things to compensate for the instability.

  Instead, org-present is a dead simple way to make a basic slide-show
  to accompany my talks and removes a bit of complexity compared to the
  exporter pipeline I used to use.

  #+BEGIN_SRC emacs-lisp
    (use-package org-present
      :ensure t
      :config
      (add-hook 'org-present-mode-hook
                   (lambda ()
                     (org-present-big)
                     (org-display-inline-images)
                     (org-present-read-only)))
         (add-hook 'org-present-mode-quit-hook
                   (lambda ()
                     (org-present-small)
                     (org-remove-inline-images)
                     (org-present-read-write))))
  #+END_SRC

  Give myself the option of hiding the mode line while doing presentations.

  #+BEGIN_SRC emacs-lisp
    (use-package hide-mode-line
      :ensure t)
  #+END_SRC

* Project navigation

** Fuzzy searching names and content

  Use Helm as the fuzzy matching search backend for projectile.

  #+BEGIN_SRC emacs-lisp
    (use-package helm
      :ensure t
      :bind
      ("M-x" . helm-M-x)
      :init
      (setq helm-M-x-fuzzy-match t))

    (use-package helm-projectile
      :ensure t
      :config
      (helm-projectile-on))

    (use-package ag
      :ensure t)

    (use-package helm-ag
      :ensure t)

    ;; For some reason, in dired-mode, projectile complains about not
    ;; being able to find tramp so make sure that it's available here:
    (use-package tramp
      :ensure t)
  #+END_SRC

** Interactively find/edit matching lines

  #+BEGIN_SRC emacs-lisp
    (use-package helm-swoop
      :ensure t
      :bind (("M-i" . 'helm-swoop)
             ("M-I" . 'helm-swoop-back-to-last-point)
             ("C-c M-i" . 'helm-multi-swoop)
             ("C-x M-i" . 'helm-multi-swoop-all))
      :init
      ;; Save buffer when helm-multi-swoop-edit complete
      (setq helm-multi-swoop-edit-save t)
      ;; If this value is t, split window inside the current window
      (setq helm-swoop-split-with-multiple-windows nil)
      ;; If this value is t, split window inside the current window
      (setq helm-swoop-split-with-multiple-windows nil)
      ;; If you prefer fuzzy matching
      (setq helm-swoop-use-fuzzy-match t)
      :config
      ;; When doing isearch, hand the word over to helm-swoop
      (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
      ;; From helm-swoop to helm-multi-swoop-all
      (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
      ;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
      (define-key helm-swoop-map (kbd "M-m") 'helm-multi-swoop-current-mode-from-helm-swoop)
      (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
      (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
      (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
      (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line))
  #+END_SRC

** Group related filesystem items into "Projects"

  Make it easier to navigate through related groups of files --
  projects.

  #+BEGIN_SRC emacs-lisp
    (use-package projectile
      :ensure t
      :init
      (setq projectile-enable-caching t)
      (setq projectile-indexing-method 'alien)
      (setq projectile-completion-system 'helm)
      (setq projectile-switch-project-action 'helm-projectile)
      (add-hook 'dired-mode-hook 'projectile-mode)
      (add-hook 'elixir-mode-hook 'projectile-mode)
      (add-hook 'js-mode-hook 'projectile-mode)
      (add-hook 'ruby-mode-hook 'projectile-mode)
      (add-hook 'web-mode-hook 'projectile-mode)
      (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
      (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
  #+END_SRC

  Make it easier to navigate between related concepts in Rails
  projects.

  #+BEGIN_SRC emacs-lisp
  (use-package projectile-rails
    :ensure t)
  #+END_SRC

* Restclient

  I sometimes work with web-y things. It's nice to not have to either
  open a terminal appication or start up an =ansi-term= session to
  fire =curl= commands. This installs the an http client -
  [[https://github.com/pashky/restclient.el][restclient]] - that I can use straight from a buffer.

  #+BEGIN_SRC emacs-lisp
    (use-package restclient
       :mode
       ("\\.rest\\'" . restclient-mode)
       ("\\.restclient\\'" . restclient-mode)
      :ensure t)
  #+END_SRC

  Furthermore, integrate =restclient= mode in to org documents via org-babel

  #+BEGIN_SRC emacs-lisp
    (use-package ob-restclient
      :ensure t)

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((restclient . t)))
  #+END_SRC

* Regular Expressions

  #+BEGIN_SRC emacs-lisp
    (use-package re-builder
      :ensure t
      :config
      (setq reb-re-syntax 'string))
  #+END_SRC

* Ruby

** ruby-mode

   Associate =ruby-mode= with ruby-ish files -- like Gemfiles,
   Rakefiles, etc.

   Prevent emacs from writing the "Magic Encoding
   Comment" at the top of source files which use exotic coding
   schemes.

   Do not indent new lines to context depth, rather use a standard
   indentation. For example, format indentations like:

   #+BEGIN_EXAMPLE
     def foo(
      bar:,
      baz:
     )
      ...
     end
   #+END_EXAMPLE

   not like this:

   #+BEGIN_EXAMPLE
     def foo(
      bar:,
      baz:
     )
      ...
     end
   #+END_EXAMPLE

   #+BEGIN_SRC emacs-lisp
     (use-package ruby-mode
       :ensure t
       :bind (
        ("C-c C-c" . xmp))
       :mode
       (("\\.rb$" . ruby-mode)
       ("\\.rake$" . ruby-mode)
       ("Rakefile$" . ruby-mode)
       ("\\.gemspec$" . ruby-mode)
       ("\\.ru$" . ruby-mode)
       ("Gemfile$" . ruby-mode)
       ("Guardfile$" . ruby-mode))
       :init
       (setq ruby-insert-encoding-magic-comment nil
       ruby-deep-indent-paren nil
       ruby-indent-tabs-mode nil)
       (add-hook 'ruby-mode 'superword-mode)
       :config
       (bind-key "M-<down>" 'ruby-forward-sexp)
       (bind-key "M-<up>" 'ruby-backward-sexp)
       (bind-key "C-c C-e" 'ruby-send-region))
   #+END_SRC

** rbenv

   I use [[http://rbenv.org/][rbenv]] to manage my ruby versions. Here I make emacs rbenv aware.

   #+BEGIN_SRC emacs-lisp
     (use-package rbenv
       :ensure t
       :init
       (setq rbenv-installation-dir (file-chase-links "/usr/local/opt/rbenv")))
  #+END_SRC

** ruby-end

   Similar to electric-paren, ruby-end takes care of automatically
   inserting end to close blocks, methods, and conditionals.

   #+BEGIN_SRC emacs-lisp
     (use-package ruby-end
       :ensure t)
   #+END_SRC

** rspec

   I, sometimes, like to run targeted groups of specs from within
   emacs. Here I make emacs aware of rspec and how to run groups of
   specs. This also enables debugging in emacs with tools like [[https://github.com/deivid-rodriguez/byebug][byebug]]
   and [[https://github.com/pry/pry][pry]].

   #+BEGIN_SRC emacs-lisp
     (use-package rspec-mode
       :ensure t
       :init
       (add-hook 'after-init-hook 'inf-ruby-switch-setup)
       :config
       (add-hook 'rspec-compilation-mode-hook
                 (lambda ()
                   (company-mode -1)
                   (make-local-variable 'compilation-scroll-output)
                   (setq compilation-scroll-output 'first-error))))
   #+END_SRC

** inf-ruby

   I want to be able to use the ruby REPL inside of emacs. This
   enables the "inferior ruby" mode

   #+BEGIN_SRC emacs-lisp
     (use-package inf-ruby
       :ensure t
       :init
       (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)
       :config
       (add-hook 'inf-ruby-mode-hook
                 (lambda ()
                   (company-mode -1))))
   #+END_SRC

** erb

   Use =web-mode= to edit ERB templates

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :mode
       ("\\.erb\\'" . web-mode)
       :init
       (setq web-mode-markup-indent-offset 2))
   #+END_SRC

** YAML

   I mostly run into YAML when dealing with ruby configuration. This
   makes it easier to work with and format YAML.

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :ensure t)
   #+END_SRC

** rcodetools

   Provide interactive example execution, ala Avdi Grimm & Ruby Tapas

   #+BEGIN_SRC emacs-lisp
     ;;; rcodetools.el -- annotation / accurate completion / browsing documentation

     ;;; Copyright (c) 2006-2008 rubikitch <rubikitch@ruby-lang.org>
     ;;;
     ;;; Use and distribution subject to the terms of the Ruby license.

     (defvar xmpfilter-command-name "ruby -S xmpfilter --dev --fork --detect-rbtest"
       "The xmpfilter command name.")
     (defvar rct-doc-command-name "ruby -S rct-doc --dev --fork --detect-rbtest"
       "The rct-doc command name.")
     (defvar rct-complete-command-name "ruby -S rct-complete --dev --fork --detect-rbtest"
       "The rct-complete command name.")
     (defvar ruby-toggle-file-command-name "ruby -S ruby-toggle-file"
       "The ruby-toggle-file command name.")
     (defvar rct-fork-command-name "ruby -S rct-fork")
     (defvar rct-option-history nil)                ;internal
     (defvar rct-option-local nil)     ;internal
     (make-variable-buffer-local 'rct-option-local)
     (defvar rct-debug nil
       "If non-nil, output debug message into *Messages*.")
     ;; (setq rct-debug t)

     (defadvice comment-dwim (around rct-hack activate)
       "If comment-dwim is successively called, add => mark."
       (if (and (eq major-mode 'ruby-mode)
                (eq last-command 'comment-dwim)
                ;; TODO =>check
                )
           (insert "=>")
         ad-do-it))
     ;; To remove this advice.
     ;; (progn (ad-disable-advice 'comment-dwim 'around 'rct-hack) (ad-update 'comment-dwim))

     (defun rct-current-line ()
       "Return the vertical position of point..."
       (+ (count-lines (point-min) (point))
          (if (= (current-column) 0) 1 0)))

     (defun rct-save-position (proc)
       "Evaluate proc with saving current-line/current-column/window-start."
       (let ((line (rct-current-line))
             (col  (current-column))
             (wstart (window-start)))
         (funcall proc)
         (goto-char (point-min))
         (forward-line (1- line))
         (move-to-column col)
         (set-window-start (selected-window) wstart)))

     (defun rct-interactive ()
       "All the rcodetools-related commands with prefix args read rcodetools' common option. And store option into buffer-local variable."
       (list
        (let ((option (or rct-option-local "")))
          (if current-prefix-arg
              (setq rct-option-local
                    (read-from-minibuffer "rcodetools option: " option nil nil 'rct-option-history))
            option))))

     (defun rct-shell-command (command &optional buffer)
       "Replacement for `(shell-command-on-region (point-min) (point-max) command buffer t' because of encoding problem."
       (let ((input-rb (concat (make-temp-name "xmptmp-in") ".rb"))
             (output-rb (concat (make-temp-name "xmptmp-out") ".rb"))
             (coding-system-for-read buffer-file-coding-system))
         (write-region (point-min) (point-max) input-rb nil 'nodisp)
         (shell-command
          (rct-debuglog (format "%s %s > %s" command input-rb output-rb))
          t " *rct-error*")
         (with-current-buffer (or buffer (current-buffer))
           (insert-file-contents output-rb nil nil nil t))
         (delete-file input-rb)
         (delete-file output-rb)))

     (defvar xmpfilter-command-function 'xmpfilter-command)
     (defun xmp (&optional option)
       "Run xmpfilter for annotation/test/spec on whole buffer.
        See also `rct-interactive'. "
       (interactive (rct-interactive))
       (rct-save-position
        (lambda ()
          (rct-shell-command (funcall xmpfilter-command-function option)))))

     (defun xmpfilter-command (&optional option)
       "The xmpfilter command line, DWIM."
       (setq option (or option ""))
       (flet ((in-block (beg-re)
                        (save-excursion
                          (goto-char (point-min))
                          (when (re-search-forward beg-re nil t)
                            (let ((s (point)) e)
                              (when (re-search-forward "^end\n" nil t)
                                (setq e (point))
                                (goto-char s)
                                (re-search-forward "# => *$" e t)))))))
         (cond ((in-block "^class.+< Test::Unit::TestCase$")
                (format "%s --unittest %s" xmpfilter-command-name option))
               ((in-block "^\\(describe\\|context\\).+do$")
                (format "%s --spec %s" xmpfilter-command-name option))
               (t
                (format "%s %s" xmpfilter-command-name option)))))

        ;;;; Completion
     (defvar rct-method-completion-table nil) ;internal
     (defvar rct-complete-symbol-function 'rct-complete-symbol--normal
       "Function to use rct-complete-symbol.")
     ;; (setq rct-complete-symbol-function 'rct-complete-symbol--icicles)
     (defvar rct-use-test-script t
       "Whether rct-complete/rct-doc use test scripts.")

     (defun rct-complete-symbol (&optional option)
       "Perform ruby method and class completion on the text around point.
        This command only calls a function according to `rct-complete-symbol-function'.
        See also `rct-interactive', `rct-complete-symbol--normal', and `rct-complete-symbol--icicles'."
       (interactive (rct-interactive))
       (call-interactively rct-complete-symbol-function))

     (defun rct-complete-symbol--normal (&optional option)
       "Perform ruby method and class completion on the text around point.
        See also `rct-interactive'."
       (interactive (rct-interactive))
       (let ((end (point)) beg
             pattern alist
             completion)
         (setq completion (rct-try-completion)) ; set also pattern / completion
         (save-excursion
           (search-backward pattern)
           (setq beg (point)))
         (cond ((eq completion t)            ;sole completion
                (message "%s" "Sole completion"))
               ((null completion)            ;no completions
                (message "Can't find completion for \"%s\"" pattern)
                (ding))
               ((not (string= pattern completion)) ;partial completion
                (delete-region beg end)      ;delete word
                (insert completion)
                (message ""))
               (t
                (message "Making completion list...")
                (with-output-to-temp-buffer "*Completions*"
                  (display-completion-list
                   (all-completions pattern alist)))
                (message "Making completion list...%s" "done")))))

     ;; (define-key ruby-mode-map "\M-\C-i" 'rct-complete-symbol)

     (defun rct-debuglog (logmsg)
       "if `rct-debug' is non-nil, output LOGMSG into *Messages*. Returns LOGMSG."
       (if rct-debug
           (message "%s" logmsg))
       logmsg)

     (defun rct-exec-and-eval (command opt)
       "Execute rct-complete/rct-doc and evaluate the output."
       (let ((eval-buffer  (get-buffer-create " *rct-eval*")))
         ;; copy to temporary buffer to do completion at non-EOL.
         (rct-shell-command
          (format "%s %s %s --line=%d --column=%d %s"
                  command opt (or rct-option-local "")
                  (rct-current-line)
                  ;; specify column in BYTE
                  (string-bytes
                   (encode-coding-string
                    (buffer-substring (point-at-bol) (point))
                    buffer-file-coding-system))
                  (if rct-use-test-script (rct-test-script-option-string) ""))
          eval-buffer)
         (message "")
         (eval (with-current-buffer eval-buffer
                 (goto-char 1)
                 (unwind-protect
                     (read (current-buffer))
                   (unless rct-debug (kill-buffer eval-buffer)))))))

     (defun rct-test-script-option-string ()
       (if (null buffer-file-name)
           ""
         (let ((test-buf (rct-find-test-script-buffer))
               (bfn buffer-file-name)
               bfn2 t-opt test-filename)
           (if (and test-buf
                    (setq bfn2 (buffer-local-value 'buffer-file-name test-buf))
                    (file-exists-p bfn2))
               ;; pass test script's filename and lineno
               (with-current-buffer test-buf
                 (setq t-opt (format "%s@%s" buffer-file-name (rct-current-line)))
                 (format "-t %s --filename=%s" t-opt bfn))
             ""))))

     (require 'cl)

     (defun rct-find-test-script-buffer (&optional buffer-list)
       "Find the latest used Ruby test script buffer."
       (setq buffer-list (or buffer-list (buffer-list)))
       (dolist (buf buffer-list)
         (with-current-buffer buf
           (if (and buffer-file-name (string-match "test.*\.rb$" buffer-file-name))
               (return buf)))))

     ;; (defun rct-find-test-method (buffer)
     ;;   "Find test method on point on BUFFER."
     ;;   (with-current-buffer buffer
     ;;     (save-excursion
     ;;       (forward-line 1)
     ;;       (if (re-search-backward "^ *def *\\(test_[A-Za-z0-9?!_]+\\)" nil t)
     ;;           (match-string 1)))))

     (defun rct-try-completion ()
       "Evaluate the output of rct-complete."
       (rct-exec-and-eval rct-complete-command-name "--completion-emacs"))

        ;;;; TAGS or Ri
     (autoload 'ri "ri-ruby" nil t)
     (defvar rct-find-tag-if-available t
       "If non-nil and the method location is in TAGS, go to the location instead of show documentation.")
     (defun rct-ri (&optional option)
       "Browse Ri document at the point.
        If `rct-find-tag-if-available' is non-nil, search the definition using TAGS.

        See also `rct-interactive'. "
       (interactive (rct-interactive))
       (rct-exec-and-eval
        rct-doc-command-name
        (concat "--ri-emacs --use-method-analyzer "
                (if (buffer-file-name)
                    (concat "--filename=" (buffer-file-name))
                  ""))))

     (defun rct-find-tag-or-ri (fullname)
       (if (not rct-find-tag-if-available)
           (ri fullname)
         (condition-case err
             (let ()
               (visit-tags-table-buffer)
               (find-tag-in-order (concat "::" fullname) 'search-forward '(tag-exact-match-p) nil  "containing" t))
           (error
            (ri fullname)))))

        ;;;;
     (defun ruby-toggle-buffer ()
       "Open a related file to the current buffer. test<=>impl."
       (interactive)
       (find-file (shell-command-to-string
                   (format "%s %s" ruby-toggle-file-command-name buffer-file-name))))

        ;;;; rct-fork support
     (defun rct-fork (options)
       "Run rct-fork.
        Rct-fork makes xmpfilter and completion MUCH FASTER because it pre-loads heavy libraries.
        When rct-fork is running, the mode-line indicates it to avoid unnecessary run.
        To kill rct-fork process, use \\[rct-fork-kill].
        "
       (interactive (list
                     (read-string "rct-fork options (-e CODE -I LIBDIR -r LIB): "
                                  (rct-fork-default-options))))
       (rct-fork-kill)
       (rct-fork-minor-mode 1)
       (start-process-shell-command
        "rct-fork" "*rct-fork*" rct-fork-command-name options))

     (defun rct-fork-default-options ()
       "Default options for rct-fork by collecting requires."
       (mapconcat
        (lambda (lib) (format "-r %s" lib))
        (save-excursion
          (goto-char (point-min))
          (loop while (re-search-forward "\\<require\\> ['\"]\\([^'\"]+\\)['\"]" nil t)
                collect (match-string-no-properties 1)))
        " "))

     (defun rct-fork-kill ()
       "Kill rct-fork process invoked by \\[rct-fork]."
       (interactive)
       (when rct-fork-minor-mode
         (rct-fork-minor-mode -1)
         (interrupt-process "rct-fork")))
     (define-minor-mode rct-fork-minor-mode
       "This minor mode is turned on when rct-fork is run.
        It is nothing but an indicator."
       :lighter " <rct-fork>" :global t)

        ;;;; unit tests
     (when (and (fboundp 'expectations))
       (require 'ruby-mode)
       (require 'el-mock nil t)
       (expectations
        (desc "comment-dwim advice")
        (expect "# =>"
                (with-temp-buffer
                  (ruby-mode)
                  (setq last-command nil)
                  (call-interactively 'comment-dwim)
                  (setq last-command 'comment-dwim)
                  (call-interactively 'comment-dwim)
                  (buffer-string)))
        (expect (regexp "^1 +# =>")
                (with-temp-buffer
                  (ruby-mode)
                  (insert "1")
                  (setq last-command nil)
                  (call-interactively 'comment-dwim)
                  (setq last-command 'comment-dwim)
                  (call-interactively 'comment-dwim)
                  (buffer-string)))

        (desc "rct-current-line")
        (expect 1
                (with-temp-buffer
                  (rct-current-line)))
        (expect 1
                (with-temp-buffer
                  (insert "1")
                  (rct-current-line)))
        (expect 2
                (with-temp-buffer
                  (insert "1\n")
                  (rct-current-line)))
        (expect 2
                (with-temp-buffer
                  (insert "1\n2")
                  (rct-current-line)))

        (desc "rct-save-position")
        (expect (mock (set-window-start * 7) => nil)
                (stub window-start => 7)
                (with-temp-buffer
                  (insert "abcdef\nghi")
                  (rct-save-position #'ignore)))
        (expect 2
                (with-temp-buffer
                  (stub window-start => 1)
                  (stub set-window-start => nil)
                  (insert "abcdef\nghi")
                  (rct-save-position #'ignore)
                  (rct-current-line)))
        (expect 3
                (with-temp-buffer
                  (stub window-start => 1)
                  (stub set-window-start => nil)
                  (insert "abcdef\nghi")
                  (rct-save-position #'ignore)
                  (current-column)))

        (desc "rct-interactive")
        (expect '("read")
                (let ((current-prefix-arg t))
                  (stub read-from-minibuffer => "read")
                  (rct-interactive)))
        (expect '("-S ruby19")
                (let ((current-prefix-arg nil)
                      (rct-option-local "-S ruby19"))
                  (stub read-from-minibuffer => "read")
                  (rct-interactive)))
        (expect '("")
                (let ((current-prefix-arg nil)
                      (rct-option-local))
                  (stub read-from-minibuffer => "read")
                  (rct-interactive)))

        (desc "rct-shell-command")
        (expect "1+1 # => 2\n"
                (with-temp-buffer
                  (insert "1+1 # =>\n")
                  (rct-shell-command "xmpfilter")
                  (buffer-string)))

        (desc "xmp")

        (desc "xmpfilter-command")
        (expect "xmpfilter --rails"
                (let ((xmpfilter-command-name "xmpfilter"))
                  (with-temp-buffer
                    (insert "class TestFoo < Test::Unit::TestCase\n")
                    (xmpfilter-command "--rails"))))
        (expect "xmpfilter "
                (let ((xmpfilter-command-name "xmpfilter"))
                  (with-temp-buffer
                    (insert "context 'foo' do\n")
                    (xmpfilter-command))))
        (expect "xmpfilter "
                (let ((xmpfilter-command-name "xmpfilter"))
                  (with-temp-buffer
                    (insert "describe Array do\n")
                    (xmpfilter-command))))
        (expect "xmpfilter --unittest --rails"
                (let ((xmpfilter-command-name "xmpfilter"))
                  (with-temp-buffer
                    (insert "class TestFoo < Test::Unit::TestCase\n"
                            "  def test_0\n"
                            "    1 + 1 # =>\n"
                            "  end\n"
                            "end\n")
                    (xmpfilter-command "--rails"))))
        (expect "xmpfilter --spec "
                (let ((xmpfilter-command-name "xmpfilter"))
                  (with-temp-buffer
                    (insert "context 'foo' do\n"
                            "  specify \"foo\" do\n"
                            "    1 + 1 # =>\n"
                            "  end\n"
                            "end\n")
                    (xmpfilter-command))))
        (expect "xmpfilter --spec "
                (let ((xmpfilter-command-name "xmpfilter"))
                  (with-temp-buffer
                    (insert "describe Array do\n"
                            "  it \"foo\" do\n"
                            "    [1] + [1] # =>\n"
                            "  end\n"
                            "end\n")
                    (xmpfilter-command))))
        (expect "xmpfilter "
                (let ((xmpfilter-command-name "xmpfilter"))
                  (with-temp-buffer
                    (insert "1 + 2\n")
                    (xmpfilter-command))))

        (desc "rct-fork")
        (expect t
                (stub start-process-shell-command => t)
                (stub interrupt-process => t)
                (rct-fork "-r activesupport")
                rct-fork-minor-mode)
        (expect nil
                (stub start-process-shell-command => t)
                (stub interrupt-process => t)
                (rct-fork "-r activesupport")
                (rct-fork-kill)
                rct-fork-minor-mode)
        ))

     (provide 'rcodetools)

   #+END_SRC

* Rust

  [[https://twitter.com/sgrif][Sean Griffin]] makes noises about [[https://www.rust-lang.org/en-US/][rust]] on the [[http://bikeshed.fm][Bikeshed]] podcast. He
  seems an intelligent and handsome man. Having spent some time with
  Go I'm going to invest some cycles trying to get to know this rust
  thing the kids are getting on about.

  #+BEGIN_SRC emacs-lisp
    (use-package flycheck-rust
      :ensure t
      :init
      (with-eval-after-load 'rust-mode
        (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)))

    (use-package rust-mode
      :ensure t
      :bind (
             ("C-c C-c" . rust-run)
             ("C-c C-b" . rust-compile)
             ("C-c C-t" . rust-test)
             ("C-c C-l" . rust-run-clippy))
      :init
      (setq rust-format-on-save t))
  #+END_SRC

  Add minor-mode for the rust package manager [[https://doc.rust-lang.org/stable/cargo/][cargo]]

  #+BEGIN_SRC emacs-lisp
    (use-package cargo
      :ensure t)
  #+END_SRC

* Shell

  I write quite a bit of bash. [[https://github.com/koalaman/shellcheck][Shellcheck]] says it can help me learn to
  be better at it. This integrates shellcheck into the flycheck system
  for shell scripts - in editor shell script linting.

  #+begin_src emacs-lisp
    ;;; Define a flycheck checker for shellcheck
    ;;; From: https://github.com/flycheck/flycheck/blob/0f144f13a07e202169acb63880d989cb41787759/doc/developer/developing.rst#writing-more-complex-checkers
    (flycheck-define-checker sh-shellcheck
      "A shell script syntax and style checker using Shellcheck.

        See URL `https://github.com/koalaman/shellcheck/'."
      :command ("shellcheck"
                "--format" "checkstyle"
                "--shell" (eval (symbol-name sh-shell))
                (option-flag "--external-sources"
                             flycheck-shellcheck-follow-sources)
                (option "--exclude" flycheck-shellcheck-excluded-warnings list
                        flycheck-option-comma-separated-list)
                "-")
      :standard-input t
      :modes sh-mode
      :error-parser flycheck-parse-checkstyle
      :error-filter (lambda (errors)
                      (flycheck-remove-error-file-names "-" errors))
      :predicate (lambda () (memq sh-shell '(bash ksh88 sh)))
      :verify
      (lambda (_)
        (let ((supported (memq sh-shell '(bash ksh88 sh))))
          (list (flycheck-verification-result-new
                 :label (format "Shell %s supported" sh-shell)
                 :message (if supported "yes" "no")
                 :face (if supports-shell 'success '(bold warning))))))
      :error-explainer
      (lambda (err)
        (let ((error-code (flycheck-error-id err))
              (url "https://github.com/koalaman/shellcheck/wiki/%S"))
          (and error-code `(url . ,(format url error-code))))))
  #+end_src

* Static site/blog generation

  I generate my [[https://aaronkuehler.com][personal website]] from a set of org-mode source
  files. I use [[I%20am%20pragmatic%20in%20my%20practice][org-page]] handle the heavy lifting. Here lies the
  necessary configuration to automate the generation and publishing
  process.

  #+BEGIN_SRC emacs-lisp
    (use-package org-page
      ;;:disabled
      :ensure t
      :config
      (setq op/repository-directory "~/Developer/indiebrain.github.io")
      (setq op/site-domain "https://aaronkuehler.com")
      (setq op/personal-github-link "https://github.com/indiebrain")
      (setq op/site-main-title "Aaron Kuehler")
      (setq op/site-sub-title "80% Scientist, 20% Artist. Theorist and Practitioner.")
      (setq op/theme-root-directory "~/Developer/indiebrain.github.io/themes")
      (setq op/theme 'indiebrain)
      (setq op/category-config-alist
            (cons '("resume"
                    :show-meta nil
                    :show-comment nil
                    :uri-generator op/generate-uri
                    :uri-template "/resume/"
                    :sort-by :date
                    :category-index nil)
                  op/category-config-alist))
      (setq op/category-ignore-list
            (cons "resume" op/category-ignore-list))
      (setq op/category-ignore-list
            (cons "drafts" op/category-ignore-list)))
  #+End_SRC

  I am human, sometimes I'm not as effective at expressing my ideas clearly in text. I use [[https://github.com/bnbeckwith/writegood-mode][writegood-mode]] to help me.

  #+BEGIN_SRC emacs-lisp
    (use-package writegood-mode
      :ensure t)
  #+END_SRC

* SASS

  Prevent =sass-mode= from compiling sass files on save

  #+BEGIN_SRC emacs-lisp
    (use-package sass-mode
      :ensure t
      :init
      (setq-default scss-compile-at-save nil))
  #+END_SRC

* web-mode

  When working with HTML templates, let's use an indentation style
  that's consistent with other coding indentation rules.

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :init
       (setq web-mode-markup-indent-offset 2)
       (setq web-mode-css-indent-offset 2)
       (setq web-mode-code-indent-offset 2)
       (setq web-mode-indent-style 2)
       (setq web-mode-block-padding 2))
   #+END_SRC
